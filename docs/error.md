문제 분석 및 해결 방안
1. 로그인 후 발생하는 불필요한 경고(alert)
현상: 사용자가 이름 **“나우창”**과 생일 **“0809”**으로 로그인하면, 로그인은 정상적으로 이루어졌음에도 불구하고 경고(Alert) 창이 나타납니다. 이 Alert에는 "로그인 실패: ..."라는 메시지가 포함되어 있어 사용자에게 오류로 인식됩니다. 하지만 실제로는 로그인에 성공하여 채팅 화면이 보여지는 상황입니다. 원인 분석: 클라이언트 측 doLogin() 함수에서 로그인 API 호출 결과를 처리하는 로직에 문제가 있을 가능성이 큽니다. 이 함수는 /api/login에 사용자 이름과 생일(4자리)을 보내고, HTTP 응답 코드가 200이 아닐 경우 catch 블록에서 곧바로 alert('로그인 실패: ...')를 호출하게 되어 있습니다. 정상적인 경우 서버는 200 응답과 함께 사용자 정보를 JSON으로 반환하므로 alert가 뜨지 말아야 합니다. 그러나 다음과 같은 이유들로 클라이언트가 성공 응답을 오류로 처리했을 가능성이 있습니다:
네트워크 지연 또는 초기 연결 문제: Render 무료 플랜에서는 앱이 Sleep 모드에서 깨우는 데 시간이 걸릴 수 있습니다. 첫 로그인 요청이 타임아웃이나 네트워크 오류로 간주되어 fetch에서 예외가 발생하면, 실제로 두번째 시도에 로그인은 성공했더라도 첫 시도의 오류 메시지가 표시될 수 있습니다.
이중 요청 처리: 로그인 버튼을 연속으로 빠르게 눌렀을 때 두 번 /api/login 호출이 발생하여 하나는 성공, 다른 하나는 불필요한 처리로 실패를 표시했을 가능성이 있습니다. 현재 코드에서는 로그인 버튼을 누르면 즉시 비활성화하거나 중복 요청을 막는 처리가 없어, 사용자가 실수로 “시작하기” 버튼을 여러 번 클릭하면 중복 요청이 갈 수 있습니다. 그 결과 두 번째 요청이 예상치 못한 응답을 받아 catch 블록을 타고 경고를 띄웠을 수 있습니다.
응답 처리 미스매치: apiCall 유틸리티는 응답이 response.ok가 아니면 오류로 간주합니다. 만약 서버가 예상과 다른 상태 코드나 JSON 포맷을 보냈다면 (예: 201 Created나 빈 응답 등), 프론트엔드가 이를 오류로 판단했을 수 있습니다. 하지만 현재 /api/login 서버코드는 항상 200 응답을 주도록 되어 있으므로 가능성은 낮습니다.
해결 방안:
로그인 버튼 비활성화 및 로딩 처리: 사용자가 “시작하기” 버튼을 누르면 즉시 버튼을 비활성화하고 로딩 중임을 표시하여 중복 로그인 시도를 막아야 합니다. 예를 들어, doLogin() 함수 진입 시 startBtn 버튼에 대해 disabled=true 설정을 하고, 로그인 응답을 받은 후에는 성공/실패 여부에 따라 버튼 상태를 복원하거나 화면 전환을 진행합니다. 현재 구현에는 Utils.setButtonLoading 함수가 있으나 로그인 버튼에는 spinner 요소가 없으므로, 간단히 텍스트 변경이나 회색처리로 피드백을 주는 것도 좋습니다. 이 수정으로 사용자가 두 번 클릭하여 두 번 요청을 보내는 상황을 방지할 수 있습니다.
오류 메시지 개선 및 조건 확인: 실제 로그인 성공 후 발생하는 alert는 사용 경험을 저해하므로, 우선 원인을 파악하기 위해 오류 메시지를 콘솔에 기록하거나 응답 데이터를 검사하는 로깅을 추가하면 도움이 됩니다. 예를 들어, catch 블록에서 console.error(error)를 수행하여 에러 객체의 상세내용을 확인하고, error.message가 어떻게 설정되는지 알아볼 수 있습니다. 그런 다음, 불필요한 alert가 뜨는 원인이 파악되면 해당 조건을 제거하거나 수정합니다. 만약 네트워크 타임아웃 등 일시적 문제였다면, alert 대신 상단 상태바에 “재시도해주세요” 등의 안내를 표시하고 자동 재시도 로직을 넣는 것도 고려할 수 있습니다.
서버 응답 검증: 서버의 /api/login 경로가 정상적으로 JSON을 반환하는지, 혹시라도 내용이 비정상적이진 않았는지 확인합니다. (예: JSON.parse 에러가 발생할 만한 잘못된 문자 등이 없는지). 필요하다면 서버 측에 로그를 심어 해당 유저 로그인 시 어떤 일이 발생하는지 살펴볼 수 있습니다. 현재 서버코드를 보면 이름/생일 유효성 검증 후 사용자 생성 또는 갱신하고, 최종적으로 res.json으로 {id, nickname, status, avatar, lastSeen}을 보내고 있어 정상입니다. 이 부분은 문제가 없어 보이므로, 프론트엔드 로직에서 불필요한 alert 표시만 제거하면 될 것으로 판단됩니다.

코드 개선 예시: (로그인 버튼 중복 클릭 방지 및 사용자 경험 개선)
async function doLogin(){
    const loginBtn = DOM.el('#startBtn');
    loginBtn.disabled = true;  // 로그인 버튼 비활성화
    const name = (DOM.el('#loginName').value||'').trim();
    const b4   = (DOM.el('#loginBirth').value||'').replace(/\D/g,'').slice(0,4);
    if(!name || b4.length !== 4){
        // 입력값 검증 실패 시 shake 효과 (기존 구현)
        loginBtn.disabled = false;
        ...
        return;
    }
    try {
        const u = await apiCall('POST', '/api/login', { name, birth4: b4 });
        // ... (로그인 성공 처리 로직)
    } catch(error) {
        console.error('Login error:', error);
        alert('로그인 실패: ' + error.message);
    } finally {
        loginBtn.disabled = false;  // 오류든 성공이든 버튼 활성화 (재로그인 대비)
    }
}
위와 같이 수정하면, 로그인 시 중복 요청을 막고, 오류 발생 시 개발자 콘솔에 원인을 기록하여 디버깅에 도움이 됩니다. 또한 실패 후에도 버튼을 재활성화하여 사용자가 입력을 수정한 뒤 다시 시도할 수 있도록 합니다.

2. 프론트엔드와 백엔드 코드 불일치 문제
여러 군데에서 프론트엔드 스크립트와 백엔드 API 혹은 데이터 구조 간에 불일치가 발견되었습니다. 이러한 불일치는 클라이언트 측 자바스크립트 오류를 유발하고, 결과적으로 기능 오작동이나 경고(alert) 발생의 원인이 됩니다. 주요 문제는 다음과 같습니다:
[A] 전역 변수 참조 오류 (userId, currentRoom 등):
프론트엔드 index.html 스크립트에서 AppState 객체로 모든 상태를 관리하도록 되어 있으나, 일부 함수에서 이를 잘못 참조하고 있습니다. 예를 들어, 메시지를 화면에 추가하는 addOrUpdateMsg() 함수 내에서 현재 사용자 ID를 비교할 때 m.userId === userId로 되어 있는데, userId라는 전역변수가 정의되어 있지 않아 ReferenceError가 발생합니다. 마찬가지로, 이모지 반응을 토글하는 reactToggle()에서도 { mid, userId, emoji }로 API 요청을 보내고 있는데, 이 userId 역시 정의되지 않은 변수입니다. 이 버그들 때문에:
메시지 전송/수신 시 오류: 새로운 메시지를 화면에 렌더링할 때 userId 참조 오류로 함수 실행이 중단되어, 메시지가 보이지 않거나 콘솔에 오류가 출력됩니다. 특히 이미지 업로드 후 미리보기 추가 시 addOrUpdateMsg()가 호출되면서 이 문제가 발생하여, 이미지가 화면에 안 나타나고 곧바로 alert('업로드 실패: ...')가 뜬 것으로 추정됩니다 (자세한 내용은 아래 3번 이슈에서 설명).
이모지 반응 기능 실패: reactToggle의 userId가 undefined로 전달되어 서버에 반응 추가 요청을 보내는 경우, 백엔드에서는 userId 필드가 비어있는 반응으로 저장됩니다. 현재 서버 /api/reactions 라우트에는 userId 유효성 검증이 없어서 에러는 없지만, 반응 배열에 undefined가 추가되어 의도한 기능이 동작하지 않습니다. 더군다나 프론트엔드는 이 호출 자체가 ReferenceError로 catch로 바로 떨어지므로, 매번 "반응 실패: userId is not defined" 경고를 띄우게 될 것입니다.
또한 Socket.IO로 수신되는 이벤트 처리 부분에서도 비슷한 문제가 있습니다. socket.on('newMessage', ...)와 socket.on('reactionUpdate', ...)에서 메시지를 받을 때, 현재 방과 일치하는지 확인하는 조건이 message.room === currentRoom로 되어 있습니다. 여기서 currentRoom도 전역으로 정의된 변수가 아니며, 아마 AppState.currentRoom을 참조해야 할 부분으로 보입니다. 이 때문에 새로운 메시지나 반응 업데이트를 받을 때도 ReferenceError가 발생하여 콘솔 에러가 나거나, 해당 이벤트 핸들러가 실행되지 못하고 중단될 가능성이 있습니다. 해결: 이러한 변수 참조 불일치를 모두 AppState 기반으로 수정해야 합니다. 즉:
m.userId === userId를 m.userId === AppState.userId로 변경
reactToggle 호출 시 { mid, userId: AppState.userId, emoji }로 변경
Socket 이벤트 핸들러의 currentRoom를 AppState.currentRoom으로, lastTs[...]를 AppState.cache.lastTs[...]로 수정
이러한 수정으로 클라이언트 스크립트가 올바른 상태 변수를 참고하게 되면, ReferenceError로 인한 경고와 기능 실패가 사라집니다.

예시로, addOrUpdateMsg 함수와 reactToggle 함수를 올바르게 고친 코드 스니펫은 다음과 같습니다:
function addOrUpdateMsg(m) {
const isMe = (m.userId === userId);
const isMe = (m.userId === AppState.userId);
row.className = 'msg-row ' + (isMe ? 'me' : 'other');
...
}
async function reactToggle(mid, emoji) {
try {
   const result = await apiCall('POST', '/api/reactions', { mid, userId, emoji });
   const result = await apiCall('POST', '/api/reactions', { mid, userId: AppState.userId, emoji });
    updateReactsView(result);
    beep();
} catch (error) {
    alert('반응 실패: ' + error.message);
}
}

이처럼 수정하면 `userId` 관련 오류가 없어지고, **로그인 후 가져온 AppState.userId** 값을 일관되게 사용하여 기능을 수행하게 됩니다.

[B] 함수/메서드 이름 불일치:
프론트엔드 코드에서 날짜 라벨을 출력할 때 formatDayLabel(m.ts) 함수를 호출하고 있습니다. 그런데 해당 함수는 정의되어 있지 않고, 대신 그 위에 DateUtils.formatDateLabel(timestamp)라는 유틸 함수가 있습니다. 원래 의도는 아마 formatDayLabel을 DateUtils.formatDateLabel로 호출하거나 별칭을 만들어 사용하는 것이었겠지만, 현재 누락된 상태입니다. 이로 인해 채팅창에 날짜 구분선(예: “2025.08.25 (월)” 등의 날짜칩)을 추가하려 할 때, formatDayLabel 미정의 오류가 발생할 수 있습니다. 만약 메시지 목록에 새로운 날짜가 등장하면 그 순간 이 함수 호출에서 에러가 나서 addOrUpdateMsg 함수가 중단될 것입니다. 해결: formatDayLabel 함수를 정의하거나, 해당 부분을 DateUtils.formatDateLabel로 수정해야 합니다. 간단하게는 addOrUpdateMsg 내부 코드를 아래처럼 고칠 수 있습니다:
sep.innerHTML = <span class="day-chip">${formatDayLabel(m.ts)}</span>;
sep.innerHTML = <span class="day-chip">${DateUtils.formatDateLabel(m.ts)}</span>;

또는 초기 스크립트 영역에 `const formatDayLabel = DateUtils.formatDateLabel;`를 추가해 주어도 됩니다. 이렇게 하면 대화 날짜 구분선 기능이 정상 동작합니다.

- **[C] 백엔드 API 사용 프로토콜 상이:** (경미한 부분)  
소스에서 클라이언트는 사용자 프로필 정보를 가져오기 위해 **`POST /api/user/:userId`**를 호출하고 있습니다:contentReference[oaicite:12]{index=12}. 일반적으로 정보를 조회하는 요청은 GET 메서드를 사용하지만, 서버 구현을 보면 해당 경로를 POST로 받아서 **사용자가 없으면 새로 생성**하는 용도로 활용하고 있습니다:contentReference[oaicite:13]{index=13}:contentReference[oaicite:14]{index=14}. 이는 설계상 다소 특이하지만 현재 프론트와 백엔드가 **같은 방식으로 동작하도록 맞춰져 있으므로** 큰 문제는 없습니다. (클라이언트가 POST로 요청하면 서버도 POST 핸들러에서 처리하여 JSON을 돌려줌) 다만 RESTful하지 않은 부분이라 개발자 혼동을 줄 수 있으므로, **메서드 통일성**을 갖추는 것이 좋습니다. 예를 들어 **GET**으로 프로필 조회, **POST**는 새 유저 생성 용도로만 쓰도록 역할을 분리하면 코드 이해가 쉬워집니다. 하지만 이 변경을 할 경우 프론트엔드 코드도 함께 수정해야 하므로, 현재 동작에 문제가 없다면 우선순위는 낮습니다.

- **[D] 백엔드 검증 누락:** 앞서 [A]에서 언급한 반응 추가 API(`/api/reactions`)의 경우, 서버 측에서 `mid`와 `userId`를 받아 메시지의 `reactions` 필드에 해당 userId를 추가/삭제합니다:contentReference[oaicite:15]{index=15}. 현재 구현에는 `userId`에 대한 유효성 체크가 없어, 잘못된 값이 들어오면 그대로 DB에 반영될 수 있습니다. 프론트엔드 버그로 `userId`가 undefined로 전달되는 상황이 이미 있었으므로, **서버에서도 방어적으로 검증을 추가**하는 것이 좋습니다. 예컨대 `/api/reactions` 핸들러의 시작 부분에:
```js
if (!userId || typeof userId !== 'string') {
    return res.status(400).json({ error: '유효하지 않은 사용자 ID입니다.' });
}
와 같은 체크를 넣어두면, 잘못된 요청 데이터를 사전에 걸러줄 수 있습니다. 이는 백엔드 안정성 향상을 위한 권장 수정 사항입니다. 요약하면, 프론트엔드와 백엔드의 데이터/변수 사용 계약을 일치시키는 것이 중요합니다. 위의 [A], [B] 항목을 수정하면 클라이언트 측 오류(alert와 기능 이상)가 대폭 해소될 것입니다. 추가로 [C], [D]에 언급된 부분을 개선하면 코드의 일관성과 견고함이 높아집니다.

3. 이미지 업로드 및 미리보기 기능 버그
현상: 사용자가 채팅에서 사진 첨부 기능을 사용할 때, 이미지를 선택해 업로드하면 미리보기가 제대로 표시되지 않는 문제가 있습니다. 기대 동작은 이미지를 업로드한 후 채팅 메시지 목록에 해당 이미지가 나타나는 것이지만, 현재는 이미지가 보이지 않거나 “업로드 실패” 경고가 뜨는 상황입니다. 이미지 업로드 흐름: 클라이언트 코드를 보면, 파일 선택 <input type="file" id="image"> 요소의 change 이벤트에서 바로 /api/upload 엔드포인트로 파일을 업로드하도록 구현되어 있습니다. 주요 흐름은:
파일 크기 제한(10MB) 검사 후,
FormData에 이미지 파일과 현재 방 이름(room), 사용자 ID(userId), 임시 메시지ID(mid)를 담아 POST 요청,
업로드가 성공하면 서버가 저장한 메시지 객체(JSON)를 응답으로 보내주고, 이를 이용해 addOrUpdateMsg(result)를 호출하여 채팅에 새로운 메시지(이미지 버블)를 추가,
업로드 중에는 AppState.flags.uploading=true로 설정하고, 완료 후 false로 되돌림. 업로드 버튼도 중간에 비활성화하여 연속 업로드 방지.
서버 측 구현을 보면 /api/upload 라우트에서 Multer 미들웨어로 이미지를 받고, 임시 디렉토리에 파일을 저장한 뒤, Message 컬렉션에 새로운 메시지를 kind:"image" 타입으로 기록합니다. 그리고 저장된 메시지 객체를 응답하며, Socket.IO를 통해 같은 방의 다른 클라이언트에게도 newMessage 이벤트로 전송합니다. 응답 JSON에는 이미지 파일 경로(mediaUrl), MIME 타입, 파일명 등이 포함됩니다. 문제 분석: 프론트엔드에서 업로드 후 미리보기가 안 나오는 원인은 2번에서 지적한 프론트엔드 버그와 직결됩니다. 구체적으로:
업로드 성공 시, 클라이언트는 result 메시지 객체를 받아 addOrUpdateMsg(result)를 호출합니다. 그러나 현재 addOrUpdateMsg 함수 내부의 userId 참조 오류로 인해 함수가 도중에 예외를 던집니다. 이 예외는 업로드 함수의 catch에서 포착되어 **alert('업로드 실패: ...')**를 띄우고 끝나기 때문에, 실제로는 업로드가 성공하고도 클라이언트에서 실패로 처리되고 있었습니다. 결과적으로 이미지 미리보기(<img> 태그 추가)가 이루어지지 않았던 것입니다.
위 문제를 수정하면(isMe 계산 시 AppState.userId 사용), addOrUpdateMsg는 정상 실행되어 이미지가 채팅창에 추가됩니다. 추가된 이미지 메시지는 <img src="/uploads/파일이름" ...> 형태로 DOM에 삽입되며, 브라우저가 즉시 이미지를 로드하여 표시하게 됩니다. 만약 이미지 로드에 실패할 경우를 대비해 onerror 핸들러로 “이미지 열기” 링크를 대신 보여주는 처리도 구현되어 있습니다. 따라서 코드 상으로는 버그만 고치면 곧바로 이미지 미리보기가 동작할 것으로 기대됩니다.
한편, 서버 측에서도 이미지 업로드 관련하여 확인할 점이 있습니다. Render의 배포 환경에서는 업로드 디렉토리로 /tmp/uploads를 사용하고 있고, static 파일 서빙도 /uploads 경로로 설정되어 있습니다. 이 설정은 올바르며, 업로드 후 응답에 담기는 mediaUrl 경로도 /uploads/파일명으로 잘 넘어옵니다. 다만 Render의 /tmp 디렉토리는 인스턴스가 재시작될 때 사라지는 임시 저장소이므로, 업로드한 이미지가 영구 보존되진 않습니다. 사용자가 페이지를 새로고침하거나 일정 시간 지나 서버가 재시작되면 이전에 올린 이미지 경로가 유효하지 않게 될 수 있음을 염두에 두어야 합니다. (이 부분은 설계상 결정 사항으로, 중요 데이터라면 Cloud storage를 사용하는 방안을 고려해야 합니다. 하지만 테스트/일시적 용도라면 현재대로도 무방합니다.)

해결 방안:
프론트엔드 버그 수정: 앞서 2번 이슈에서 제시한 대로 addOrUpdateMsg 함수의 isMe 계산 부분을 고치는 것이 최우선입니다. 이를 수정한 후에는 실제로 업로드 성공 시 이미지 <img> 요소가 채팅창에 추가되어 미리보기가 정상 동작할 것입니다. 또한 reactToggle의 userId 오류를 고쳐두면, 이미지에 대한 이모지 반응을 추가할 때도 오류 없이 처리됩니다 (예: 업로드된 사진에 “👍” 반응 추가 등).
업로드 UI 피드백 개선: 현재도 업로드 과정에서 #photoBtn 버튼을 일시 비활성화하고, 업로드 완료 후 다시 활성화하는 처리가 되어 있습니다. 사용자에게 용량 초과 시 경고(alert('10MB 이하만 업로드 가능합니다.'))도 제공하고 있어 기본적인 UX는 갖춰졌습니다. 추가로 개선한다면, 업로드 진행 중에 스피너 애니메이션을 버튼에 표시하거나, 업로드 완료 후 텍스트 입력창을 비우는 작업(현재 메시지 전송의 경우만 구현됨)을 해도 좋겠습니다. 이미지 업로드 후에는 DOM.el('#image').value = ''로 파일 선택을 리셋하고 있으므로 연속 업로드에도 문제 없습니다.

예외 상황 처리: 이미지 업로드 실패 시 현재는 alert로 오류 메시지를 보여주는데, 이 부분도 사용자 친화적으로 바꿀 수 있습니다. 예를 들어 네트워크 단절이나 서버 오류로 업로드 실패한 경우, alert 대신 채팅창에 시스템 메시지 형태로 “이미지 전송 실패. 다시 시도해주세요.”라는 안내를 띄우는 방법도 있습니다. 그러나 우선순위는 낮으며, 핵심은 업로드 실패의 주된 원인이 되었던 앞선 버그를 잡는 것입니다.
서버측 추가 검증: Multer를 통해 이미지를 저장하는 부분에서 파일 타입 필터링과 크기 제한이 잘 되어 있습니다. 혹시 모를 오류에 대비해, /api/upload 핸들러에도 파일이나 필수 필드(room, userId) 존재 여부를 검증하는 것이 좋습니다. 현재 코드에서도 !req.file이면 400 오류를 보내고 있고, 방 이름 room이 유효한지 체크하고 있습니다. userId에 대해서는 별도 검증이 없으나, 이후 메시지 저장 시 User.findOne({id: userId})를 호출하므로 잘못된 ID면 메시지에 nickname이 “User-undefined” 형태로 저장될 수 있습니다. 이 부분도 앞서 말한 대로 프론트 버그 수정으로 자연히 해결되지만, 안정성을 높이려면 백엔드에서도 if (!isValidUserId(userId)) return res.status(400)...; 검증을 추가해주는 것이 안전합니다.
수정 후에는 이미지 미리보기 기능이 정상화될 것으로 예상됩니다. 즉, 사용자가 이미지를 업로드하면 곧바로 채팅 창에 썸네일이 나타나고, 다른 사용자들도 Socket.IO 실시간 메시지를 통해 그 이미지를 볼 수 있게 됩니다. 아래는 수정된 addOrUpdateMsg의 

일부로, 이미지 메시지를 추가하는 코드입니다 (변경사항 반영):
const isMe = (m.userId === AppState.userId);  // 내 메시지인지 확인
...
if (m.kind === 'image' && m.mediaUrl) {
    const key = m.mid || m.ts;
    bubbleInner = 
      `<div><img id="img-${key}" src="${m.mediaUrl}" alt="${m.fileName||'image'}" 
             style="max-width:100%; border-radius:12px;" /></div>
       <div class="meta">${m.nickname||''} · ${DateUtils.formatDateLabel(m.ts)}</div>`;
} else {
    ...
}

이처럼 수정하여 배포하면, 보고된 문제들이 해결되어 로그인 → 채팅 → 이미지 전송 → 이모지 반응까지 일련의 기능이 모두 의도한 대로 동작할 것입니다.

✅ 결론 및 요약
위에서 파악한 원인들은 대부분 프론트엔드 자바스크립트 코드의 버그 또는 프론트-백엔드 간 데이터 처리 불일치에서 기인했습니다. 구체적인 개선 사항을 정리하면 다음과 같습니다:
로그인 로직 개선: 중복 클릭 방지 및 에러처리 로직 보완. 로그인 성공 시 불필요한 alert가 뜨지 않도록 하고, 실제 오류 원인은 콘솔 등에 기록하여 추후 디버깅에 활용.
클라이언트 상태관리 일원화: AppState를 통해 관리되는 값들은 반드시 AppState 경유하여 참조하도록 코드 정리. (userId, currentRoom 등 전역 변수 혼용 제거)
이름 불일치/오타 수정: formatDayLabel 함수 누락분을 바로잡아 날짜 구분선 기능 복구.
메시지 및 반응 기능 복원: 위 수정으로 채팅 메시지 추가, 이미지 미리보기, 이모지 반응 토글 등 핵심 기능의 버그가 해결됨. 특히 이미지 업로드 후 미리보기 이미지가 대화에 표시되고, 반응 버튼 클릭 시 더 이상 에러 alert 없이 정상 동작할 것입니다.
서버측 안정성 추가: /api/reactions 등의 엔드포인트에 입력값 검증을 추가하여 프론트엔드 오류가 있더라도 서버 오동작을 방지하도록 개선.
이상의 수정을 적용한 후에는, 개발자 콘솔의 오류 로그가 사라지고 사용자가 경고창 없이 부드럽게 앱을 이용할 수 있을 것입니다. 각 기능을 수동 테스트하며 (로그인 → 메시지 전송 → 이미지 업로드 → 탭 전환(주중/주말 등) → 이모지 반응 → 로그아웃) 문제가 재발생하지 않는지 확인하시기 바랍니다. 수정 사항이 프론트/백엔드 양쪽 코드에 걸쳐 있으므로 배포 시 둘 다 최신 버전으로 반영되어야 함을 유의해주세요. 모든 문제가 해결되면 Eastalk 웹 애플리케이션은 의도된 대로 안정적으로 동작할 것입니다.