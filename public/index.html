<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Eastalk (Web)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  
  <!-- PWA 매니페스트 - 404 에러 방지를 위한 조건부 로딩 -->
  <script>
    // 리소스 존재 확인 후 동적으로 로드 (404 오류 방지)
    async function loadResourceIfExists(url, type = 'link') {
      try {
        const response = await fetch(url, { method: 'HEAD' });
        if (response.ok) {
          const element = document.createElement(type === 'link' ? 'link' : 'script');
          if (type === 'link') {
            if (url.includes('manifest.json')) {
              element.rel = 'manifest';
            } else if (url.includes('favicon')) {
              element.rel = 'icon';
            }
            element.href = url;
          }
          document.head.appendChild(element);
        }
      } catch (error) {
        console.log(`[리소스] ${url} 로딩 건너뜀 (404 방지):`, error.message);
      }
    }
    
    // 페이지 로드 후 선택적 리소스 로딩
    document.addEventListener('DOMContentLoaded', () => {
      loadResourceIfExists('/manifest.json');
      loadResourceIfExists('/favicon.ico');
    });
  </script>
  
  <!-- 기본 favicon 대신 data URI 사용 (404 방지) -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>💬</text></svg>" />
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>💬</text></svg>" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="Eastalk" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="theme-color" content="#007bff" />
  <style>
    /* ===== Design Tokens ===== */
    :root{
      --bg:#ffffff; --panel:#ffffff; --line:#e5e7eb;
      --text:#111827; --muted:#6b7280;
      --accent:#ffd400; --accent-ink:#111;
      /* 카카오톡 스타일 말풍선 색상 개선 */
      --bubble-me:#ffe066; /* 카카오톡 노란색과 유사 */
      --bubble-other:#ffffff; /* 깔끔한 흰색 배경 */

      --radius-sm:10px; --radius-md:12px; --radius-lg:16px;
      --shadow-1:0 1px 2px rgba(0,0,0,.06);
      --shadow-2:0 6px 24px rgba(0,0,0,.08);
      --focus: 0 0 0 3px rgba(0,0,0,.08), 0 0 0 6px rgba(255,212,0,.45);
      
      /* Material Design 3 기반 통합 타이포그래피 시스템 */
      --font-size-headline-lg: 24px;
      --font-size-headline: 20px;
      --font-size-body: 16px;
      --font-size-label: 14px;
      --font-size-small: 12px;
      
      /* 통합 spacing 시스템 */
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --spacing-xl: 32px;
      
      /* 통합 터치 타겟 크기 */
      --touch-target-min: 44px; /* iOS HIG 최소값 */
      --touch-target-recommended: 48px; /* MD3 권장값 */
      --touch-target-comfortable: 56px; /* 편안한 크기 */
    }
    
    /* 데스크톱 조정 */
    @media (min-width: 769px) {
      :root {
        --font-size-headline-lg: 28px;
        --font-size-headline: 24px;
        --spacing-md: 20px;
        --spacing-lg: 28px;
        --spacing-xl: 40px;
      }
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,sans-serif;
      background:var(--bg); color:var(--text);
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
      font-size: var(--font-size-body);
    }
    
    /* ===== 통합 버튼 디자인 시스템 ===== */
    button { 
      cursor: pointer; 
      touch-action: manipulation;
      font: inherit;
    }
    
    .btn, .mobile-nav-btn, .btn-save, .btn-primary {
      /* Material Design 3 버튼 스타일 */
      font-size: var(--font-size-label);
      font-weight: 500;
      border-radius: var(--radius-md);
      padding: var(--spacing-sm) var(--spacing-md);
      min-height: var(--touch-target-recommended);
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
      border: none;
      background: var(--accent);
      color: var(--accent-ink);
      position: relative;
      overflow: hidden;
    }
    
    /* 호버 효과 */
    .btn:hover:not(:disabled), 
    .mobile-nav-btn:hover:not(:disabled),
    .btn-save:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: var(--shadow-2);
    }
    
    /* 클릭 효과 */
    .btn:active:not(:disabled),
    .mobile-nav-btn:active:not(:disabled) {
      transform: translateY(0);
      transition-duration: 0.1s;
    }
    
    /* 비활성화 상태 */
    button:disabled, 
    .btn:disabled,
    .btn[disabled],
    .btn-save[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    }
    
    /* 로딩 스피너 */
    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid rgba(0,0,0,0.1);
      border-top-color: currentColor;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      display: inline-block;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* ===== App Shell ===== */
    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 16px; 
      padding-left:max(16px, env(safe-area-inset-left));
      padding-right:max(16px, env(safe-area-inset-right));
      padding-top:max(12px, env(safe-area-inset-top));
      border-bottom:1px solid var(--line);
      background:#fafafa; position:sticky; top:0; z-index:100;
    }
    header .brand{ font-weight:700; letter-spacing:.2px; font-size: var(--font-size-headline); }
    header .brand span{ color:var(--accent); }
    #topStatus{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:40vw; }

    .wrap{
      display:flex; gap:12px; padding:12px; max-width:1024px; margin:0 auto;
      height:calc(100vh - 56px); overflow:hidden; min-height:0;
    }
    @supports (height: 100dvh){
      .wrap{ height:calc(100dvh - 56px); }
    }
    @supports (height: 100svh){
      .wrap{ height:calc(100svh - 56px); }
    }

    .left,.right{ background:var(--panel); border:1px solid var(--line); border-radius:var(--radius-lg); }
    .left{ width:320px; padding:12px; overflow:auto; -webkit-overflow-scrolling:touch; touch-action:pan-y; }
    .right{ flex:1; display:flex; flex-direction:column; min-height:0; }

    /* ===== Profile ===== */
    .profile{ display:flex; align-items:center; gap:12px; }
    .avatar{ width:48px; height:48px; border-radius:50%; background:#e5e7eb; overflow:hidden; }
    .avatar img{ width:100%; height:100%; object-fit:cover; display:block; }
    .fields{ margin-top:12px; display:grid; gap:8px; }
    .status{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color:var(--muted); font-size:12px; }

    /* Inputs & Buttons */
    .input{
      width:100%; padding:12px 14px; border:1px solid var(--line); border-radius:var(--radius-sm);
      font-size:16px; background:#fff; color:var(--text); transition:border-color .15s, box-shadow .15s;
      touch-action:manipulation; /* 터치 최적화 */
    }
    .input::placeholder{ color:var(--muted); }
    .input:focus{ outline:none; border-color:#d1d5db; box-shadow:var(--focus); }

    .btn{
      display:inline-flex; align-items:center; justify-content:center; gap:8px;
      min-height:44px; height:44px; padding:12px 16px; border-radius:999px; border:1px solid transparent;
      font-weight:700; cursor:pointer; user-select:none; transition:transform .02s, box-shadow .15s;
      touch-action:manipulation; /* 더블탭 확대 방지 */
      -webkit-touch-callout: none; /* iOS Safari 길게 누르기 메뉴 방지 */
      -webkit-user-select: none; /* iOS Safari 텍스트 선택 방지 */
      -webkit-tap-highlight-color: transparent; /* iOS Safari 터치 하이라이트 방지 */
    }
    .btn:active{ transform:translateY(1px); }
    .btn[disabled]{ opacity:.6; cursor:not-allowed; }
    .btn-primary{ background:var(--accent); color:var(--accent-ink); box-shadow:var(--shadow-1); }
    .btn-ghost{ background:#fff; color:var(--text); border:1px solid var(--line); }
    
    /* 메시지 입력창의 사진 버튼 개선 - Material Design 3 스타일 적용 */
    .composer .btn-icon {
      background: #f3f4f6 !important;
      border: none !important;
      border-radius: 10px !important;
      color: var(--text) !important;
      box-shadow: var(--shadow-1) !important;
      transition: all 0.2s ease !important;
      font-size: 18px !important;
    }
    
    .composer .btn-icon:hover:not(:disabled) {
      background: #e5e7eb !important;
      box-shadow: var(--shadow-2) !important;
      transform: translateY(-1px) !important;
    }
    
    .composer .btn-icon:active:not(:disabled) {
      transform: translateY(0) !important;
      box-shadow: var(--shadow-1) !important;
      background: #d1d5db !important;
    }
    
    /* 보내기 버튼 텍스트 정렬 개선 */
    .composer .btn-primary {
      white-space: nowrap !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      min-width: 60px !important;
      height: 44px !important;
    }
    
    .composer .btn-primary .label-txt {
      display: inline-block !important;
      white-space: nowrap !important;
      line-height: 1 !important;
    }
    
    /* 모바일에서도 전송 텍스트 사용 */
    @media (max-width: 768px) {
      .composer .btn-primary {
        min-width: 50px !important;
        padding: 0 8px !important;
        font-size: 14px !important;
      }
    }
    .btn-icon{ width:44px; padding:0; }

    .spinner{ width:16px; height:16px; border-radius:50%; border:2px solid currentColor; border-top-color:transparent; animation:spin .8s linear infinite; }
    @keyframes spin{ to{ transform:rotate(360deg); } }

    /* Tabs (모바일: 가로 스크롤) */
    .tabs{
      display:flex; gap:8px; padding:10px; border-bottom:1px solid var(--line); background:#fafafa;
      overflow-x:auto; -webkit-overflow-scrolling:touch; scrollbar-width:thin;
      white-space:nowrap; touch-action:pan-y;
    }
    .tab{
      display:inline-flex; align-items:center; justify-content:center;
      padding:8px 12px; border:1px solid var(--line); border-radius:999px; background:#fff; cursor:pointer;
      max-width:50vw; text-overflow:ellipsis; overflow:hidden; white-space:nowrap;
      min-height:36px; /* 터치 영역 확보 */
      touch-action:manipulation; /* 터치 최적화 */
    }
    .tab.active{ background:var(--accent); color:var(--accent-ink); border-color:transparent; }

    /* Messages Container - 외부 스크롤 컨테이너 */
    .messages-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0; /* flexbox 컨테이너에서 필수 */
      background: #fff;
      position: relative;
      overflow: hidden; /* 내부 스크롤만 허용 */
    }
    
    /* Messages - 내부 스크롤 영역 */
    .messages {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 12px;
      /* 메시지와 입력창 사이 충분한 여백 확보 */
      padding-bottom: 120px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      /* 최신 스크롤 최적화 */
      -webkit-overflow-scrolling: touch;
      overscroll-behavior-y: contain; /* 스크롤 체인 방지 */
      scroll-behavior: smooth;
      /* 스크롤바 스타일링 */
      scrollbar-width: thin;
      scrollbar-color: var(--line) transparent;
    }
    
    /* 웹킷 기반 브라우저 스크롤바 커스터마이징 */
    .messages::-webkit-scrollbar {
      width: 6px;
    }
    .messages::-webkit-scrollbar-track {
      background: transparent;
    }
    .messages::-webkit-scrollbar-thumb {
      background: var(--line);
      border-radius: 3px;
    }
    .messages::-webkit-scrollbar-thumb:hover {
      background: var(--muted);
    }
    .msg-row{ display:flex; align-items:flex-end; gap:8px; position:relative; }
    .msg-row.me{ justify-content:flex-end; }
    /* 🔗 답글/스레드 스타일 추가 */
    .msg-row.reply{ margin-left:32px; }
    .msg-row.reply::before{ 
      content:''; position:absolute; left:-24px; top:0; width:2px; height:100%; 
      background:var(--line); border-radius:1px; 
    }
    .msg-row.reply .thread-indicator{
      position:absolute; left:-32px; top:12px; width:20px; height:2px; 
      background:var(--line); border-radius:1px;
    }
    .msg-row.me.reply{ margin-right:32px; margin-left:0; }
    .msg-row.me.reply::before{ left:auto; right:-24px; }
    .msg-row.me.reply .thread-indicator{ left:auto; right:-32px; }
    
    /* avatar button (clickable) */
    .avatar-sm{
      width:28px; height:28px; border-radius:50%; background:#e5e7eb; overflow:hidden;
      flex:0 0 28px; display:flex; align-items:center; justify-content:center; font-size:12px; color:#6b7280;
      border:0; padding:0; cursor:pointer;
    }
    .avatar-sm img{ width:100%; height:100%; object-fit:cover; display:block; }
    
    /* 말풍선과 답글 버튼 컨테이너 */
    .message-container{ display:flex; align-items:flex-end; gap:6px; max-width:86%; }
    .msg-row.me .message-container{ flex-direction:row-reverse; }
    
    .bubble{ 
      /* 카카오톡 스타일: 조금 더 둥글게, 조금 더 간결하게 */
      padding: 10px 14px;
      border: none; /* 카카오톡은 보더 없음 */
      border-radius: 18px; /* 더 둥근 모서리 */
      line-height: 1.5;
      background: var(--bubble-other);
      /* 카카오톡 스타일 그림자 */
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      flex: 1;
      /* 더 부드러운 타이포그래피 */
      word-break: break-word;
      word-wrap: break-word;
    }
    .msg-row.me .bubble{ 
      background: var(--bubble-me);
      /* 내 메시지는 오른쪽 정렬을 위한 스타일 */
      margin-left: auto;
      margin-right: 0;
    }
    
    /* 🔗 답글 버튼 스타일 */
    .reply-btn{
      width:24px; height:24px; border-radius:50%; 
      background:#fff; border:1px solid var(--line); 
      display:flex; align-items:center; justify-content:center;
      cursor:pointer; opacity:0; transition:opacity .2s;
      color:var(--muted); font-size:14px; flex-shrink:0;
    }
    .reply-btn:hover{ background:var(--accent); color:var(--accent-ink); border-color:var(--accent); }
    .msg-row:hover .reply-btn{ opacity:1; }
    
    /* 👑 관리자 삭제 버튼 스타일 */
    .admin-delete-btn{
      width:24px; height:24px; border-radius:50%; 
      background:#fff; border:1px solid #ef4444; 
      display:flex; align-items:center; justify-content:center;
      cursor:pointer; opacity:0; transition:all .2s;
      color:#ef4444; font-size:12px; flex-shrink:0;
      margin-left:4px;
    }
    .admin-delete-btn:hover{ background:#ef4444; color:#fff; transform:scale(1.1); }
    .msg-row:hover .admin-delete-btn{ opacity:1; }
    
    /* 답글 대상 표시 (카카오톡 스타일) */
    .reply-target{
      font-size:12px; color:var(--muted); margin-bottom:4px; 
      padding:6px 8px; background:#f8f9fa; border-radius:6px;
      border-left:3px solid var(--accent); cursor:pointer;
      transition:background-color .2s ease;
    }
    .reply-target:hover{
      background:#e9ecef;
    }
    .reply-target .original-user{
      color:var(--text); font-weight:500;
    }
    .reply-target .original-content{
      display:block; margin-top:2px; color:var(--muted);
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      max-width:200px;
    }
    .meta{ font-size:11px; color:var(--muted); margin-top:6px; }

    /* Reactions */
    .reacts{ margin-top:8px; display:flex; align-items:center; gap:6px; flex-wrap:wrap; }
    .chip{ display:inline-flex; align-items:center; gap:4px; padding:2px 8px; border:1px solid var(--line); border-radius:999px; font-size:12px; background:#fff; cursor:pointer; user-select:none; }
    .chip.mine{ border-color:#f59e0b; background:#fff7e6; }
    .add-react{ border:1px dashed var(--line); background:#fff; border-radius:999px; padding:2px 10px; font-size:12px; cursor:pointer; }
    .picker{ display:flex; gap:6px; margin-left:2px; }
    .picker.hidden{ display:none; }
    .pick{ background:#fff; border:1px solid var(--line); border-radius:8px; padding:4px 6px; cursor:pointer; }

    /* 🔗 답글 상태 표시 스타일 */
    .reply-status{
      background:var(--bubble-me); border-top:1px solid var(--line);
      padding:8px 12px; position:sticky; bottom:60px; z-index:4;
    }
    .reply-info{
      display:flex; align-items:center; justify-content:space-between;
      font-size:14px; color:var(--text);
    }
    .cancel-reply{
      width:20px; height:20px; border:none; background:none; 
      cursor:pointer; color:var(--muted); font-size:16px;
      display:flex; align-items:center; justify-content:center;
      border-radius:50%;
    }
    .cancel-reply:hover{ background:rgba(0,0,0,.1); color:var(--text); }

    /* Composer (safe-area 고려) */
    .composer{
      display:flex;
      /* Apple HIG: 16pt spacing between elements */
      gap: 12px;
      padding: 12px;
      /* Apple HIG: Safe area insets */
      padding-left: max(16px, env(safe-area-inset-left));
      padding-right: max(16px, env(safe-area-inset-right));
      padding-bottom: max(12px, env(safe-area-inset-bottom));
      border-top: 1px solid var(--line);
      /* iOS-style backdrop */
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      position: sticky;
      bottom: 0;
      z-index: 3;
      /* Enhanced shadow for depth */
      box-shadow: 0 -8px 24px rgba(0,0,0,.08);
    }
    .composer .input{ 
      /* Apple HIG: Better touch target and typography */
      height: 52px;
      font-size: 17px; /* iOS 권장 폰트 크기 */
      line-height: 1.4;
      padding: 12px 16px;
      border-radius: 12px;
      /* iOS-style input behavior */
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      /* Better focus state */
      transition: border-color 0.15s ease, box-shadow 0.15s ease;
    }

    /* Login Overlay */
    .auth{ position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.35); backdrop-filter:blur(2px); z-index:9999; }
    .auth.hidden{ display:none; }
    .dialog{ width:min(460px, calc(100vw - 32px)); border-radius:20px; background:#fff; border:1px solid var(--line); box-shadow:var(--shadow-2); }
    .dialog header{ position:relative; border-bottom:1px solid var(--line); background:#fff; border-radius:20px 20px 0 0; cursor:grab; }
    .dialog main{ padding:16px; display:grid; gap:12px; }
    .field{ display:grid; gap:6px; }
    .label{ font-size:12px; color:var(--muted); }
    .helper{ font-size:12px; color:var(--muted); }
    .row-actions{ padding:12px 16px 16px; display:flex; gap:8px; }
    .dialog .btn-primary{ width:100%; height:48px; }
    body.auth-open{ overflow:hidden; }
    .shake{ animation:shake .28s ease-in-out; }
    @keyframes shake{ 0%,100%{ transform:translateX(0);} 25%{ transform:translateX(-6px);} 75%{ transform:translateX(6px);} }





    .dropdown-header {
      padding: 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid var(--line);
      background: #fafafa;
    }

    .dropdown-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      object-fit: cover;
      background: var(--line);
    }

    .dropdown-info {
      flex: 1;
      min-width: 0;
    }

    .dropdown-name {
      font-weight: 600;
      font-size: 14px;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .dropdown-status {
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
    }

    .dropdown-actions {
      padding: 8px;
    }

    .dropdown-item {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      border: none;
      background: transparent;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.15s ease;
      font-size: 14px;
      color: var(--text);
      text-align: left;
      font-family: inherit;
    }

    .dropdown-item:hover {
      background: #f3f4f6;
    }

    .dropdown-item.danger {
      color: #EF4444;
    }

    .dropdown-item.danger:hover {
      background: #FEE2E2;
    }

    .item-icon {
      font-size: 16px;
      width: 20px;
      text-align: center;
    }

    .dropdown-divider {
      height: 1px;
      background: var(--line);
      margin: 4px 0;
    }

    /* Work Status Selector Modal - Mobile Responsive */
    .work-status-modal {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: 10000;
      animation: fadeIn 0.2s ease-out;
      padding: 16px;
      box-sizing: border-box;
    }

    /* Mobile viewport adjustments */
    @media (max-width: 768px) {
      .work-status-modal {
        place-items: end center;
        padding: 0;
      }
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .work-status-dialog {
      width: min(400px, calc(100vw - 32px));
      max-height: 80vh;
      overflow-y: auto;
      background: white;
      border-radius: 16px;
      box-shadow: var(--shadow-2);
      animation: slideUp 0.2s ease-out;
    }

    /* Mobile drawer-style bottom sheet */
    @media (max-width: 768px) {
      .work-status-dialog {
        width: 100%;
        max-height: 85vh;
        border-radius: 20px 20px 0 0;
        animation: slideUpFromBottom 0.3s cubic-bezier(0.32, 0.72, 0, 1);
        touch-action: pan-y;
      }

      @keyframes slideUpFromBottom {
        from {
          transform: translateY(100%);
          opacity: 0.8;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .status-header {
      padding: 20px;
      border-bottom: 1px solid var(--line);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .status-title {
      font-size: 18px;
      font-weight: 700;
      color: var(--text);
    }

    .status-close {
      width: 32px;
      height: 32px;
      display: grid;
      place-items: center;
      border: none;
      background: transparent;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.15s ease;
      color: var(--muted);
      font-size: 20px;
    }

    .status-close:hover {
      background: #f3f4f6;
    }

    .status-options {
      padding: 12px;
      display: grid;
      gap: 8px;
    }

    .status-option {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      border: 1px solid var(--line);
      background: white;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.15s ease;
      text-align: left;
    }

    .status-option:hover {
      background: #fafafa;
      border-color: var(--accent);
    }

    .status-option.active {
      background: var(--accent);
      border-color: var(--accent);
    }

    .status-option-icon {
      font-size: 24px;
      width: 32px;
      text-align: center;
    }

    .status-option-info {
      flex: 1;
    }

    .status-option-name {
      font-weight: 600;
      font-size: 14px;
      color: var(--text);
    }

    .status-option-desc {
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
    }

    .status-option.active .status-option-name,
    .status-option.active .status-option-desc {
      color: var(--accent-ink);
    }

    /* 임시 선택된 상태 스타일 */
    .status-option.selected {
      background: rgba(0, 123, 255, 0.1);
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent);
    }

    .status-option.selected .status-option-name {
      color: var(--accent);
      font-weight: 700;
    }

    .status-option.selected .status-option-desc {
      color: var(--accent);
    }

    /* 저장/취소 버튼 스타일 */
    .status-actions {
      padding: 12px;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      border-top: 1px solid var(--border);
      background: #fafafa;
    }

    .status-cancel-btn,
    .status-save-btn {
      padding: 8px 16px;
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .status-cancel-btn {
      background: white;
      color: var(--text);
    }

    .status-cancel-btn:hover {
      background: #f5f5f5;
    }

    .status-save-btn {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .status-save-btn:hover {
      background: #0056b3;
      border-color: #0056b3;
    }

    /* ===== Mobile layout tweaks ===== */
    /* Profile Button - Now Always Visible */
    #profileBtn{ display:inline-flex; }
    #scrim{ display:none; position:fixed; inset:0; background:rgba(0,0,0,.35); z-index:15; }
    
    /* 소형 모바일 (480px 이하) */
    @media (max-width: 480px){
      .wrap{ padding:6px; gap:6px; }
      .left{ padding:8px; }
      .right{ padding:0; }
      header{ padding:8px 12px; }
      header .brand{ font-size:14px; }
      .tabs{ padding:6px; }
      .tab{ padding:6px 10px; font-size:13px; }
      .messages{ padding:8px; }
      /* 모바일 스크롤 최적화 */
      .messages-container { 
        height: 100%; 
        min-height: 0;
        max-height: calc(100vh - 200px); /* 헤더, 탭, 입력창 공간 확보 */
      }
      .composer{ padding:8px; gap:6px; }
      .connected-users .user-avatar{ width:24px; height:24px; font-size:10px; }
      .connected-users{ gap:2px; }
    }
    
    /* 모바일 & 태블릿 (880px 이하) */
    @media (max-width: 880px){
      .wrap{ flex-direction:column; gap:8px; }
      .right{ order:2; }
      .left{ display:none; }
      .profile-info{ display:none; } /* Hide text on mobile */
      .profile-trigger{ padding:8px; justify-content:center; }
      #topStatus{ display:none; }
      body.profile-open #scrim{ display:block; }
      body.profile-open .left{
        display:block; position:fixed; z-index:20;
        top:56px; bottom:calc(84px + max(0px, env(safe-area-inset-bottom))); 
        left:max(8px, env(safe-area-inset-left)); right:max(8px, env(safe-area-inset-right));
        border-radius:16px; overflow:auto; -webkit-overflow-scrolling:touch; touch-action:pan-y;
      }
      /* 모바일 접속자 목록 - 기본 크기 */
      .connected-users .user-avatar{ width:28px; height:28px; font-size:11px; }
      .btn{ min-height:44px; height:44px; } /* 터치 최소 크기 보장 */
      .btn-icon{ width:44px; min-height:44px; }
      .bubble{ max-width:92%; }
      .messages{ padding-bottom:120px; }
      .tabs .tab{ max-width:60vw; }
    }
    
    /* iOS Safari 전용 터치 최적화 */
    @supports (-webkit-touch-callout: none) {
      .btn {
        /* iOS Safari 실제 디바이스 터치 최적화 */
        -webkit-touch-callout: none !important;
        -webkit-user-select: none !important;
        -webkit-tap-highlight-color: transparent !important;
        touch-action: manipulation !important;
        /* iOS Safari 터치 대기시간 최소화 */
        -webkit-user-drag: none !important;
        -webkit-transform: translate3d(0,0,0); /* 하드웨어 가속 강제 */
      }
      
      /* iOS Safari 전송 버튼 특별 최적화 */
      #sendBtn {
        /* iOS Safari 터치 응답성 극대화 */
        -webkit-touch-callout: none !important;
        -webkit-user-select: none !important;
        -webkit-tap-highlight-color: rgba(0,0,0,0) !important;
        touch-action: manipulation !important;
        -webkit-user-drag: none !important;
        /* 터치 영역 확장 (최소 44x44px 보장) */
        min-width: 44px !important;
        min-height: 44px !important;
        /* 하드웨어 가속으로 터치 지연 최소화 */
        -webkit-transform: translate3d(0,0,0);
        will-change: transform;
        /* iOS Safari 터치 시작 지연 최소화 */
        -webkit-transform-style: preserve-3d;
      }
      
      /* iOS Safari에서 터치 반응성 향상 */
      .composer {
        -webkit-touch-callout: none !important;
        touch-action: pan-x pan-y !important;
      }
    }
    
    /* iPhone/iPad 전용 미디어쿼리 */
    @media screen and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait) {
      #sendBtn {
        /* 높은 DPI iOS 디바이스 터치 최적화 */
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        backface-visibility: hidden;
        perspective: 1000;
      }
    }
    
    /* 기존 480px 이하 추가 스타일 */
    @media (max-width: 480px){
      .composer .input{ 
        height: 50px;
        font-size: 16px; /* iOS 확대 방지 */
        padding: 10px 14px;
        border-radius: 10px;
      }
      .tabs .tab{ max-width:70vw; }
      
      /* 소형 모바일: 입력창 버튼만 적절한 크기 유지 */
      .composer .btn-icon {
        width: 44px !important;
        height: 44px !important;
        font-size: 18px !important;
        border-radius: 10px !important;
      }
      
      .composer .btn {
        min-height: 44px !important;
        height: 44px !important;
        font-size: 14px !important;
        border-radius: 10px !important;
        padding: 0 14px !important;
      }
      
      /* 헤더 버튼들은 더 작게 */
      header .btn {
        min-height: 32px !important;
        height: 32px !important;
        padding: 0 10px !important;
        font-size: 12px !important;
        max-width: 100px;
      }
      
      /* 더 작은 화면에서 여백 최적화 */
      .composer {
        /* 소형 모바일에서도 대칭적 여백 유지 */
        margin-bottom: 12px;
        margin-top: 12px;
        padding: 6px 16px;
        gap: 8px;
      }
      
      .wrap {
        /* 소형 모바일도 동일한 비율 유지 */
        padding-bottom: calc(68px + max(12px, env(safe-area-inset-bottom)));
      }
      
      /* 소형 모바일에서 더 작은 접속자 아바타 적용 */
      .connected-users .user-avatar{ width:24px; height:24px; font-size:10px; }
      .connected-users{ gap:2px; }
      /* 더 작은 화면에서 접속자 아바타 크기 조정 */
      .connected-users .user-avatar{ width:26px; height:26px; font-size:10px; }
      .connected-users .users-grid{ gap:3px; }
    }

    /* ===== Day separator (카톡 스타일 개선) ===== */
    .day-sep{ 
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 16px 0;
      color: var(--muted);
      font-size: 11px;
      font-weight: 500;
    }
    .day-sep::before, .day-sep::after{ 
      content: "";
      flex: 1;
      height: 1px;
      background: rgba(0, 0, 0, 0.08); /* 카카오톡 스타일 연한 라인 */
    }
    .day-chip{ 
      background: rgba(0, 0, 0, 0.05); /* 카카오톡 스타일 연한 배경 */
      border: none;
      border-radius: 12px;
      padding: 6px 12px;
      font-size: 11px;
      font-weight: 500;
      color: #666;
    }
    body.win98 .day-sep::before, body.win98 .day-sep::after{ background:#808080; }
    body.win98 .day-chip{
      background:#c0c0c0;
      border:2px solid #c0c0c0; border-top-color:#fff; border-left-color:#fff;
      border-right-color:#404040; border-bottom-color:#404040;
    }

    /* ===== 카카오톡 스타일 메시지 그룹핑 ===== */
    .msg-group {
      margin-bottom: 8px;
    }
    
    /* 연속 메시지 그룹에서 첫 번째 메시지 */
    .msg-row.first-in-group .bubble {
      margin-bottom: 2px;
    }
    
    /* 연속 메시지 그룹에서 마지막 메시지 */
    .msg-row.last-in-group .bubble {
      margin-bottom: 8px;
    }
    
    /* 연속 메시지에서 중간 메시지들 */
    .msg-row.middle-in-group {
      margin-bottom: 2px;
    }
    
    /* 카카오톡 스타일: 연속 메시지의 보다 자연스러운 모서리 */
    .msg-row.first-in-group .bubble {
      border-bottom-left-radius: 6px; /* 대화 상대방 쪽 모서리 줄임 */
    }
    
    .msg-row.first-in-group.me .bubble {
      border-bottom-right-radius: 6px; /* 내 메시지 오른쪽 모서리 줄임 */
      border-bottom-left-radius: 18px; /* 왼쪽은 유지 */
    }
    
    .msg-row.middle-in-group .bubble {
      border-bottom-left-radius: 6px;
      border-top-left-radius: 6px;
    }
    
    .msg-row.middle-in-group.me .bubble {
      border-bottom-right-radius: 6px;
      border-top-right-radius: 6px;
      border-bottom-left-radius: 18px;
      border-top-left-radius: 18px;
    }
    
    .msg-row.last-in-group .bubble {
      border-top-left-radius: 6px;
      border-bottom-left-radius: 18px; /* 마지막은 다시 원래대로 */
    }
    
    .msg-row.last-in-group.me .bubble {
      border-top-right-radius: 6px;
      border-bottom-right-radius: 18px;
      border-top-left-radius: 18px;
      border-bottom-left-radius: 18px;
    }

    /* ===== 연속 메시지 메타 정보 최소화 ===== */
    .msg-row.middle-in-group .meta,
    .msg-row.first-in-group .meta {
      opacity: 0.3;
      font-size: 10px;
    }
    
    /* 카카오톡 스타일: 반응 버튼 위치 조정 */
    .msg-row .add-react {
      margin-top: 4px;
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.05);
      border: none;
      padding: 4px 8px;
      font-size: 11px;
      color: #666;
    }

    /* ===== Load More Button ===== */
    .load-more-btn{
      position: sticky; top: 0; z-index: 10;
      width: 100%; padding: 8px 16px; margin-bottom: 8px;
      background: var(--card-bg); border: 1px solid var(--line);
      border-radius: 8px; color: var(--accent);
      font-size: 13px; font-weight: 500;
      cursor: pointer; transition: all 0.2s ease;
      display: flex; align-items: center; justify-content: center; gap: 6px;
    }
    .load-more-btn:hover{ background: var(--hover-bg); }
    .load-more-btn:disabled{ opacity: 0.6; cursor: not-allowed; }
    .load-more-spinner{ font-size: 12px; }
    
    /* Win98 스타일 */
    body.win98 .load-more-btn{
      background: #c0c0c0; color: #000;
      border: 2px solid #c0c0c0;
      border-top-color: #fff; border-left-color: #fff;
      border-right-color: #404040; border-bottom-color: #404040;
    }
    body.win98 .load-more-btn:hover{
      border-top-color: #404040; border-left-color: #404040;
      border-right-color: #fff; border-bottom-color: #fff;
    }

    /* ===== Connected Users ===== */
    .connected-users{ margin-top:16px; }
    .connected-header{ font-size:12px; color:var(--muted); margin-bottom:8px; font-weight:500; }
    .users-grid{ display:flex; flex-wrap:wrap; gap:4px; }
    .user-avatar{ 
      width:32px; height:32px; border-radius:50%; background:#e5e7eb; 
      overflow:hidden; cursor:pointer; border:2px solid transparent;
      transition:border-color .15s, transform .02s;
      display:flex; align-items:center; justify-content:center;
      font-size:12px; color:#6b7280; font-weight:500;
    }
    .user-avatar:hover{ border-color:var(--accent); transform:scale(1.05); }
    .user-avatar img{ width:100%; height:100%; object-fit:cover; display:block; }

    /* Win98 스타일 */
    body.win98 .connected-users{ border-top:1px solid #808080; padding-top:8px; }
    body.win98 .connected-header{ color:#404040; }
    body.win98 .user-avatar{ 
      background:#c0c0c0; color:#000;
      border:2px solid #c0c0c0; border-top-color:#fff; border-left-color:#fff;
      border-right-color:#404040; border-bottom-color:#404040;
    }
    body.win98 .user-avatar:hover{ 
      border-top-color:#404040; border-left-color:#404040;
      border-right-color:#fff; border-bottom-color:#fff;
      transform:none;
    }

    /* ===== Profile Modal ===== */
    .pmodal{ 
      position:fixed; inset:0; display:none; place-items:center; 
      z-index:10001; /* 접속자 모달(10000)보다 위에 표시 */
      padding: 16px; box-sizing: border-box;
    }
    .pmodal.show{ display:grid; }
    .pback{ 
      position:absolute; inset:0; background:rgba(0,0,0,.32); /* MD3 scrim opacity */
      z-index:10000; /* 접속자 모달과 같은 레벨로 설정 */
    }
    .pcard{
      position:relative; width:min(420px, calc(100vw - 32px));
      background:#fff; border:1px solid var(--line); border-radius:16px; box-shadow:var(--shadow-2);
      padding:16px; display:grid; gap:12px; 
      z-index:10001; /* 프로필 카드가 접속자 모달(10000)보다 위에 나타나도록 */
      max-height: calc(100vh - 32px);
      overflow-y: auto;
    }

    /* Mobile drawer-style profile modal */
    @media (max-width: 768px) {
      .pmodal {
        place-items: end center;
        padding: 0;
      }

      .pcard {
        width: 100%;
        max-height: 90vh;
        border-radius: 20px 20px 0 0;
        animation: profileSlideUpFromBottom 0.3s cubic-bezier(0.32, 0.72, 0, 1);
      }

      @keyframes profileSlideUpFromBottom {
        from {
          transform: translateY(100%);
          opacity: 0.8;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
    }
    .pclose{ position:absolute; top:8px; right:8px; border:0; background:#fff; border:1px solid var(--line); border-radius:8px; padding:6px 8px; cursor:pointer; }
    .pavatar{ width:100%; display:grid; place-items:center; }
    .pavatar img{ width:180px; height:180px; border-radius:50%; object-fit:cover; background:#e5e7eb; }
    .pname{ font-weight:700; font-size:16px; text-align:center; }
    .pstatus{ font-size:14px; color:var(--muted); text-align:center; word-break:break-word; }
    @media (max-width:480px){ .pavatar img{ width:140px; height:140px; } }

    /* Retro98 변형 */
    body.win98 .pcard{ background:#c0c0c0; border:2px solid #808080; }
    body.win98 .pclose{
      background:#c0c0c0; border:2px solid #c0c0c0; border-top-color:#fff; border-left-color:#fff; border-right-color:#404040; border-bottom-color:#404040;
    }

    /* ===== Retro 98 Theme ===== */
    body.win98{
      --panel:#c0c0c0; --line:#808080; --text:#000; --muted:#404040; --accent:#c0c0c0; --accent-ink:#000;
    }
    body.win98, body.win98 *{
      border-radius:0 !important; box-shadow:none !important;
      font-family: Tahoma, Verdana, "MS Sans Serif", Arial, sans-serif !important; font-size:12px;
    }
    .w98-out{ border:2px solid #c0c0c0; border-top-color:#fff; border-left-color:#fff; border-right-color:#404040; border-bottom-color:#404040; background:#c0c0c0; }
    .w98-in{ border:2px solid #808080; border-top-color:#404040; border-left-color:#404040; border-right-color:#fff; border-bottom-color:#fff; background:#fff; }

    body.win98 header{ background:linear-gradient(#000080,#1084d0); color:#fff; border-bottom:2px solid #000; }
    body.win98 header .brand span{ color:#fff; }
    body.win98 .left, body.win98 .right, body.win98 .tabs, body.win98 .composer, body.win98 .dialog{ background:#c0c0c0; }
    body.win98 .messages{ background:#fff; border:2px solid #808080; border-top-color:#404040; border-left-color:#404040; border-right-color:#fff; border-bottom-color:#fff; }

    body.win98 .input{ height:24px; padding:4px 6px; border:2px solid #808080; border-top-color:#404040; border-left-color:#404040; border-right-color:#fff; border-bottom-color:#fff; }
    body.win98 .input:focus{ outline:1px dotted #000; box-shadow:none; }

    body.win98 .btn{ height:26px; padding:0 10px; border:2px solid #c0c0c0; border-top-color:#fff; border-left-color:#fff; border-right-color:#404040; border-bottom-color:#404040; background:#c0c0c0; color:#000; font-weight:400; }
    body.win98 .btn:active{ border-top-color:#404040; border-left-color:#404040; border-right-color:#fff; border-bottom-color:#fff; }
    body.win98 .btn-primary{ background:#c0c0c0; }
    body.win98 .btn-icon{ width:26px; }

    body.win98 .tab{ border:2px solid #c0c0c0; border-top-color:#fff; border-left-color:#fff; border-right-color:#404040; border-bottom-color:#404040; background:#c0c0c0; }
    body.win98 .tab.active{ border-top-color:#404040; border-left-color:#404040; border-right-color:#fff; border-bottom-color:#fff; color:#000; }

    body.win98 .bubble{ background:#fff !important; color:#000; border:1px solid #000; padding:8px 10px; }
    body.win98 .meta{ color:#404040; }

    body.win98 .chip, body.win98 .add-react, body.win98 .pick{
      background:#c0c0c0; color:#000;
      border:2px solid #c0c0c0; border-top-color:#fff; border-left-color:#fff; border-right-color:#404040; border-bottom-color:#404040;
    }
    body.win98 .chip.mine{ background:#ffffe1; }

    body.win98 .composer{ background:#c0c0c0; }
    body.win98 .composer .input{ height:24px; }

    body.win98 .dialog{ background:#c0c0c0; }
    body.win98 .dialog header{ background:linear-gradient(#000080,#1084d0)!important; color:#fff!important; border-bottom:2px solid #000; }
    body.win98 .dialog header::after{ content:" _  □  X "; position:absolute; right:10px; top:8px; color:#fff; font-family:"Courier New",monospace; font-weight:700; }

    @media (max-width:880px){
      body.win98{ font-size:11px; }
      body.win98 .btn{ height:24px; }
      body.win98 .btn-icon{ width:24px; }
      body.win98 .input{ height:22px; }
    }

    /* ===== 로딩 및 스켈레톤 UI ===== */
    .loading-skeleton {
      padding: 20px;
      text-align: center;
      color: var(--muted);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      animation: pulse 2s ease-in-out infinite;
    }
    
    .loading-skeleton::before {
      content: '';
      width: 16px;
      height: 16px;
      border: 2px solid var(--line);
      border-top: 2px solid var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .message-skeleton {
      padding: 12px 16px;
      display: flex;
      gap: 12px;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .message-skeleton-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--line);
    }

    .message-skeleton-content {
      flex: 1;
    }

    .message-skeleton-name {
      width: 80px;
      height: 14px;
      background: var(--line);
      border-radius: 4px;
      margin-bottom: 6px;
    }

    .message-skeleton-text {
      width: 200px;
      height: 16px;
      background: var(--line);
      border-radius: 4px;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* 부드러운 전환 애니메이션 */
    .tab {
      transition: all 0.2s ease;
      transform: scale(1);
    }

    .tab:active {
      transform: scale(0.98);
    }

    .tab.active {
      transform: scale(1);
      box-shadow: 0 2px 8px rgba(255, 212, 0, 0.3);
    }

    /* 🚀 이미지 지연 로딩 스타일 */
    .lazy-image {
      transition: opacity 0.3s ease;
      opacity: 0.7;
    }

    .lazy-image.loaded {
      opacity: 1;
    }

    .lazy-image.loading {
      opacity: 0.5;
    }

    /* ===== Profile Edit Modal ===== */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 70;
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }

    .modal-container {
      background: var(--panel);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-2);
      width: min(480px, calc(100vw - 32px));
      max-height: calc(100vh - 64px);
      overflow: hidden;
      animation: modalSlideIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes modalSlideIn {
      from {
        transform: scale(0.9) translateY(20px);
        opacity: 0;
      }
      to {
        transform: scale(1) translateY(0);
        opacity: 1;
      }
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--line);
      background: var(--panel);
    }

    .modal-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 700;
      color: var(--text);
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 24px;
      color: var(--muted);
      cursor: pointer;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
    }

    .modal-close:hover {
      background: var(--line);
      color: var(--text);
    }

    .modal-content {
      padding: 20px;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    /* Profile Image Section */
    .profile-image-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      margin-bottom: 24px;
    }

    .current-profile-image {
      position: relative;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      overflow: hidden;
      background: var(--line);
    }

    .current-profile-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .profile-image-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
      display: flex;
      justify-content: center;
      align-items: end;
      padding: 8px;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .current-profile-image:hover .profile-image-overlay {
      opacity: 1;
    }

    .change-image-btn {
      background: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 16px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      font-weight: 600;
      color: #333;
      cursor: pointer;
      transition: background 0.15s ease;
    }

    .change-image-btn:hover {
      background: rgba(255, 255, 255, 1);
    }

    .upload-area {
      width: 100%;
      max-width: 400px;
      margin: 0 auto;
    }

    /* Profile Info Section */
    .profile-info-section {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .input-group label {
      font-weight: 600;
      color: var(--text);
      font-size: 14px;
    }

    .input-group input,
    .input-group textarea {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid var(--line);
      border-radius: var(--radius-sm);
      font-size: 16px;
      background: var(--panel);
      color: var(--text);
      transition: border-color 0.15s ease, box-shadow 0.15s ease;
      resize: none;
    }

    .input-group input:focus,
    .input-group textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(255, 212, 0, 0.1);
    }

    .char-count {
      font-size: 12px;
      color: var(--muted);
      text-align: right;
      margin-top: -4px;
    }

    /* Modal Footer */
    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      padding: 16px 20px;
      border-top: 1px solid var(--line);
      background: var(--panel);
    }

    .btn-cancel {
      background: var(--panel);
      color: var(--muted);
      border: 1px solid var(--line);
    }

    .btn-cancel:hover {
      background: var(--line);
      color: var(--text);
    }

    .btn-save {
      background: var(--accent);
      color: var(--accent-ink);
      border: 1px solid var(--accent);
    }

    .btn-save:hover {
      background: #ffda1a;
    }

    .btn-save:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .modal-overlay {
        padding: 0;
      }

      .modal-container {
        width: 100%;
        max-height: 95vh;
        border-radius: 20px 20px 0 0;
        animation: modalSlideUpFromBottom 0.3s cubic-bezier(0.32, 0.72, 0, 1);
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        margin: 0;
      }

      @keyframes modalSlideUpFromBottom {
        from {
          transform: translateY(100%);
          opacity: 0.8;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
    }

    @media (max-width: 480px) {
      .modal-container {
        max-height: 98vh;
      }

      .current-profile-image {
        width: 100px;
        height: 100px;
      }

      .modal-header {
        padding: 12px 16px;
      }

      .modal-content {
        padding: 16px;
      }

      .modal-footer {
        padding: 12px 16px;
      }

      .modal-footer .btn {
        flex: 1;
      }
    }

    /* Uppy Dashboard Customization */
    .uppy-Dashboard {
      border-radius: var(--radius-md) !important;
      border: 2px dashed var(--line) !important;
      background: var(--panel) !important;
    }

    .uppy-Dashboard-inner {
      border: none !important;
    }

    .uppy-Dashboard--modal .uppy-Dashboard-overlay {
      background: rgba(0, 0, 0, 0.5) !important;
    }

    /* Win98 Theme Support */
    body.win98 .modal-container {
      border-radius: 0 !important;
      border: 2px solid #c0c0c0;
      border-top-color: #fff;
      border-left-color: #fff;
      border-right-color: #404040;
      border-bottom-color: #404040;
      box-shadow: none !important;
    }

    body.win98 .modal-header {
      background: linear-gradient(#000080, #1084d0);
      color: #fff;
      border-bottom: 2px solid #000;
    }

    body.win98 .modal-close {
      background: #c0c0c0;
      border: 2px solid #c0c0c0;
      border-top-color: #fff;
      border-left-color: #fff;
      border-right-color: #404040;
      border-bottom-color: #404040;
      color: #000;
      border-radius: 0 !important;
    }

    body.win98 .input-group input,
    body.win98 .input-group textarea {
      border: 2px solid #808080;
      border-top-color: #404040;
      border-left-color: #404040;
      border-right-color: #fff;
      border-bottom-color: #fff;
      border-radius: 0 !important;
    }

    /* Mobile Navigation Menu */
    .mobile-nav {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--panel);
      border-top: 1px solid var(--line);
      z-index: 900; /* Material Design 3: 네비게이션 레이어 */
      /* 파란색 선끼리 여백 동일하게 - 헤더 패딩과 맞춰서 6px 적용 */
      padding: 6px 0 max(6px, env(safe-area-inset-bottom));
      /* iOS-style backdrop blur */
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      background: rgba(255, 255, 255, 0.85);
    }

    /* Hide mobile nav when modal is open */
    body:has(.modal-overlay[style*="flex"]) .mobile-nav,
    body:has(.work-status-modal[style*="grid"]) .mobile-nav,
    body:has(.pmodal.show) .mobile-nav,
    body:has(#connectedUsersModal[style*="grid"]) .mobile-nav {
      display: none !important;
    }

    .mobile-nav-buttons {
      display: flex;
      justify-content: space-around;
      align-items: center;
      max-width: 100%;
      margin: 0 auto;
      /* 더 균등하게 배치 */
      gap: 8px;
      padding: 0 16px;
    }

    .mobile-nav-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      color: var(--text);
      /* 통합 타이포그래피 적용 */
      font-size: var(--font-size-small);
      font-weight: 500;
      letter-spacing: 0.01em;
      cursor: pointer;
      border-radius: var(--radius-sm);
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      min-height: var(--touch-target-recommended);
      /* Material Design 3 터치 타겟 적용 */
      width: 52px;
      height: 48px;
      padding: 4px;
      /* iOS-style button appearance */
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      /* 글자 오버플로우 방지 */
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .mobile-nav-btn:hover {
      background: var(--hover);
    }

    .mobile-nav-btn .icon {
      font-size: 20px;
      margin-bottom: 1px;
      /* Better icon alignment */
      line-height: 1;
      display: block;
    }

    @media (max-width: 768px) {
      .mobile-nav {
        display: block;
      }

      /* Adjust main content to account for mobile nav */
      .wrap {
        /* 모바일 네비 높이(48px) + 패딩(12px*2) + safe area */
        padding-bottom: calc(60px + max(6px, env(safe-area-inset-bottom)));
      }
      
      /* 메시지 영역 하단 여백: 입력창 높이 + 입력창 마진 */
      .messages {
        padding-bottom: calc(60px + 12px) !important; /* 입력창 + 위아래 마진(6px*2) */
        margin-bottom: 0;
      }

      /* Mobile chat input improvements */
      .composer {
        /* 빨간색 선끼리 여백 동일하게 - 더 작은 값으로 6px 적용 */
        margin-bottom: 6px;
        margin-top: 6px;
        padding: 8px 20px;
        /* Improved safe area handling */
        padding-left: max(20px, env(safe-area-inset-left));
        padding-right: max(20px, env(safe-area-inset-right));
        /* 더 깔끔한 배경 분리 */
        border-top: 1px solid rgba(0, 0, 0, 0.06);
      }

      /* 메시지 입력창 버튼들만 크게 유지 */
      .composer .btn-icon {
        width: 48px !important;
        height: 48px !important;
        min-width: 48px !important;
        min-height: 48px !important;
        font-size: 20px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        border-radius: 12px !important;
      }

      .composer .btn {
        min-height: 48px !important;
        height: 48px !important;
        padding: 0 16px !important;
        font-size: 15px !important;
        font-weight: 600 !important;
        border-radius: 12px !important;
        /* 글자 오버플로우 방지 */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      
      /* 헤더 버튼들은 작게 유지 */
      header .btn,
      .tabs .btn,
      .mobile-nav .btn {
        min-height: 36px !important;
        height: 36px !important;
        padding: 0 12px !important;
        font-size: 13px !important;
        font-weight: 500 !important;
        border-radius: 8px !important;
        /* 글자 오버플로우 방지 */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 120px;
      }
        font-size: 16px !important;
      }
    }

    /* Connected Users Modal Styles */
    .connected-users-list {
      padding: 16px 0;
    }

    .mobile-user-item {
      display: flex;
      align-items: center;
      padding: 12px 20px;
      border-bottom: 1px solid var(--line);
      cursor: pointer;
      transition: background-color 0.15s ease;
    }

    .mobile-user-item:hover {
      background: var(--hover);
    }

    .mobile-user-item:last-child {
      border-bottom: none;
    }

    .mobile-user-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--muted);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 18px;
      color: var(--text);
      margin-right: 16px;
      overflow: hidden;
    }

    .mobile-user-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .mobile-user-info {
      flex: 1;
    }

    .mobile-user-name {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 4px;
    }

    .mobile-user-status {
      font-size: 14px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .mobile-work-status {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 12px;
      background: var(--line);
    }
  </style>
  <script src="/socket.io/socket.io.js"></script>
</head>
<body class="auth-open">
  <header>
    <div class="brand">Eastalk <span>• Web</span></div>
    <div style="display:flex; gap:8px; align-items:center;">
      <button id="toggle98" class="btn btn-ghost">🖥️ Retro 98</button>
      <button id="logoutBtn" class="btn btn-ghost">로그아웃</button>
      <div class="status" id="topStatus">—</div>
    </div>
  </header>

  <div class="wrap" aria-disabled="true">
    <!-- LEFT (Profile Drawer on mobile) -->
    <aside class="left">
      <!-- 프로필 정보 (읽기 전용) -->
      <div class="profile">
        <div class="avatar"><img id="avatarImg" alt="" /></div>
        <div>
          <div id="nicknameView" style="font-weight:700;">User</div>
          <div id="statusView" class="status">상태메시지…</div>
        </div>
      </div>
      
      <!-- 업무 상태 표시 (디자인상 숨김) -->
      <div class="work-status-display" style="display: none;">
        <div style="font-size:12px; color:#6b7280; margin-bottom:6px;">현재 업무</div>
        <div style="display:flex; align-items:center; gap:8px;">
          <span id="sidebarStatusIcon" style="font-size:20px;">⚪</span>
          <span id="sidebarStatusText" style="font-weight:600; font-size:14px;">오프라인</span>
        </div>
      </div>
      
      <!-- 빠른 작업 버튼들 -->
      <div class="quick-actions" style="margin-top:16px; display:grid; gap:8px;">
        <button class="btn btn-ghost" onclick="openProfileEditModal()" style="justify-content:flex-start;">
          <span>✏️</span> 프로필 편집
        </button>
        <button class="btn btn-ghost" onclick="openWorkStatusSelector()" style="justify-content:flex-start;">
          <span>🔄</span> 업무 상태 변경
        </button>
      </div>
      
      <!-- 로그인 안내 (로그인 전에만 표시) -->
      <div class="status" id="loginNotice" style="margin-top:16px;">* 로그인 완료 후 사용 가능합니다.</div>

      <!-- 현재 접속자 -->
      <div class="connected-users" id="connectedUsers" style="display:none">
        <div class="connected-header" id="connectedHeader">현재 접속자 (0)</div>
        <div class="users-grid" id="usersGrid"></div>
      </div>
    </aside>

    <!-- RIGHT -->
    <section class="right">
      <div class="tabs" id="tabs"></div>
      <div class="messages-container">
        <button id="loadMoreBtn" class="load-more-btn" style="display: none;">
          <span class="load-more-text">100개 더 보기</span>
          <span class="load-more-spinner" style="display: none;">⏳</span>
        </button>
        <div class="messages" id="messages"></div>
      </div>

      <!-- 🔗 답글 상태 표시 영역 -->
      <div id="replyIndicator" class="reply-status" style="display:none;">
        <div class="reply-info">
          <span id="replyText">↳ <strong id="replyTarget"></strong>님에게 답글</span>
          <button id="cancelReply" class="cancel-reply" title="답글 취소">✕</button>
        </div>
      </div>
      
      <div class="composer">
        <input id="text" class="input" placeholder="메시지 입력 (Enter 전송, Shift+Enter 줄바꿈)" disabled />
        <button id="photoBtn" class="btn btn-ghost btn-icon" title="사진">📷</button>
        <button id="sendBtn" class="btn btn-primary">
          <span class="label-txt">전송</span>
          <span class="spinner" style="display:none"></span>
        </button>
      </div>

      <form id="uploadForm" style="display:none">
        <input type="file" id="image" name="image" accept="image/*" />
      </form>
    </section>
  </div>

  <!-- Mobile Navigation -->
  <nav class="mobile-nav">
    <div class="mobile-nav-buttons">
      <button class="mobile-nav-btn" onclick="openProfileEditModal()" title="프로필 편집">
        <span class="icon">✏️</span>
        <span>프로필</span>
      </button>
      <button class="mobile-nav-btn" onclick="openWorkStatusSelector()" title="업무 상태 변경">
        <span class="icon">🔄</span>
        <span>상태</span>
      </button>
      <button class="mobile-nav-btn" onclick="openConnectedUsersModal()" title="접속자 목록">
        <span class="icon">👥</span>
        <span>접속자</span>
      </button>
      <button class="mobile-nav-btn" onclick="showProfileModal(AppState.me?.nickname, AppState.me?.avatar, AppState.me?.status)" title="내 프로필 보기">
        <span class="icon">👤</span>
        <span>정보</span>
      </button>
    </div>
  </nav>

  <!-- LOGIN -->
  <div class="auth" id="auth" role="dialog" aria-modal="true" aria-labelledby="dlg-title">
    <div class="dialog" id="dialogCard">
      <header id="dlgDragHandle">
        <div style="padding:12px 16px; font-weight:700;" id="dlg-title">Eastalk 로그인</div>
      </header>
      <main>
        <div class="helper">이름과 생일 4자리(MMDD)를 입력하면 기존 정보를 불러옵니다. 없으면 새 계정을 만들어요.</div>
        <div class="field">
          <label class="label" for="loginName">이름</label>
          <input id="loginName" class="input" placeholder="예: 홍길동" autocomplete="off" autocapitalize="off" spellcheck="false" />
        </div>
        <div class="field">
          <label class="label" for="loginBirth">생일 4자리</label>
          <input id="loginBirth" class="input" placeholder="MMDD" maxlength="4" inputmode="numeric" autocomplete="off" />
        </div>
      </main>
      <div class="row-actions">
        <button id="startBtn" class="btn btn-primary">시작하기</button>
      </div>
    </div>
  </div>

  <!-- PROFILE MODAL -->
  <div class="pmodal" id="pmodal" aria-hidden="true">
    <div class="pback" id="pback"></div>
    <div class="pcard" role="dialog" aria-modal="true" aria-labelledby="pname">
      <button class="pclose" id="pclose" aria-label="닫기">✕</button>
      <div class="pavatar"><img id="pimg" alt="프로필 사진" /></div>
      <div class="pname" id="pname">User</div>
      <div class="pstatus" id="pstatus">상태메시지…</div>
      
      <!-- 💼 현재 업무 상태 -->
      <div class="work-status-modal-display" style="margin-top: 20px; padding: 15px; background: #f9f9f9; border-radius: 8px;">
        <div style="font-weight: 600; margin-bottom: 12px; display: flex; align-items: center; gap: 6px;">
          💼 현재 업무
        </div>
        <div style="display: flex; align-items: center; gap: 12px;">
          <span id="modalStatusIcon" style="font-size: 24px;">⚪</span>
          <div>
            <div id="modalStatusText" style="font-weight: 500; font-size: 14px;">오프라인</div>
            <div id="modalStatusDesc" style="font-size: 12px; color: #6b7280;">업무 종료</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ===== 상태 관리 =====*/
    // 상수 정의
    const CONFIG = {
      ROOMS: ['주중', '주말', '전체', '방문예정'],
      EMOJIS: ['👍', '😂', '😮', '😢', '😡', '❤️'],
      MAX_MESSAGE_LENGTH: 2000,
      MAX_FILE_SIZE: 10 * 1024 * 1024, // 10MB
      SCROLL_THRESHOLD: 80
    };

    /* ===== Work Status System ===== */
    const WorkStatus = {
      ticketing: { 
        icon: '🎫', 
        text: '발권', 
        color: '#3B82F6'
      },
      checking: { 
        icon: '✅', 
        text: '검표', 
        color: '#10B981'
      },
      patrol: { 
        icon: '🚶', 
        text: '순찰', 
        color: '#F59E0B'
      },
      artshop: { 
        icon: '🎨', 
        text: '아트샵', 
        color: '#8B5CF6'
      },
      offline: { 
        icon: '⚪', 
        text: '오프라인', 
        color: '#6B7280'
      }
    };

    // Current work status
    let currentWorkStatus = 'offline';
    let selectedWorkStatus = 'offline'; // 임시 선택 상태

    /* ===== 전역 스크롤 네비게이션 함수 ===== */
    // 🔗 답글 클릭시 원본 메시지로 스크롤하는 전역 함수 (즉시 정의)
    console.log('🌍 전역 scrollToMessage 함수 정의 중...');
    
    function scrollToMessage(messageId) {
      console.log(`🌍 전역 scrollToMessage 호출: ${messageId}`);
      
      if (!messageId) {
        console.warn('⚠️ messageId가 제공되지 않았습니다');
        return false;
      }
      
      // ScrollManager가 초기화되어 있으면 사용
      if (window.ScrollManager && window.ScrollManager.scrollToMessage) {
        console.log('📋 ScrollManager를 통해 스크롤 실행');
        return window.ScrollManager.scrollToMessage(messageId);
      } else {
        console.warn('ScrollManager가 아직 초기화되지 않았습니다. 대체 방법 시도...');
        
        // ScrollManager가 없을 경우 직접 스크롤 시도
        const targetElement = document.querySelector(`[data-mid="${messageId}"]`);
        if (targetElement) {
          console.log('🎯 대체 방법으로 요소 발견, 스크롤 시도');
          targetElement.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center' 
          });
          
          // 하이라이트 효과
          targetElement.style.transition = 'background-color 0.3s ease';
          targetElement.style.backgroundColor = '#fff3cd';
          setTimeout(() => {
            targetElement.style.backgroundColor = '';
            setTimeout(() => {
              targetElement.style.transition = '';
            }, 300);
          }, 1000);
          
          return true;
        } else {
          console.error(`❌ 메시지 요소를 찾을 수 없습니다: ${messageId}`);
          return false;
        }
      }
    }
    
    // 전역 스코프에 함수 할당 (즉시)
    window.scrollToMessage = scrollToMessage;

    /* ===== 이미지 압축 및 최적화 시스템 ===== */
    
    /**
     * 이미지 파일을 압축하고 최적화합니다
     * @param {File} file - 압축할 이미지 파일
     * @param {Object} options - 압축 옵션
     * @param {number} options.maxWidth - 최대 폭 (기본값: 1920)
     * @param {number} options.maxHeight - 최대 높이 (기본값: 1080)
     * @param {number} options.quality - JPEG 품질 (기본값: 0.8)
     * @param {string} options.outputFormat - 출력 포맷 (기본값: 'image/jpeg')
     * @returns {Promise<Object>} {dataUrl, size, originalSize, compressionRatio}
     */
    async function optimizeImage(file, options = {}) {
      const {
        maxWidth = 1920,
        maxHeight = 1080,
        quality = 0.8,
        outputFormat = 'image/jpeg'
      } = options;
      
      console.log('[압축] 이미지 최적화 시작:', file.name, `원본: ${(file.size/1024).toFixed(2)}KB`);
      
      return new Promise((resolve, reject) => {
        const img = new Image();
        
        img.onload = function() {
          try {
            // Canvas 요소 생성
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // 원본 이미지 크기
            let { width: originalWidth, height: originalHeight } = img;
            
            // 비율 유지하면서 크기 조정 계산
            let newWidth = originalWidth;
            let newHeight = originalHeight;
            
            if (originalWidth > maxWidth || originalHeight > maxHeight) {
              const aspectRatio = originalWidth / originalHeight;
              
              if (originalWidth > originalHeight) {
                newWidth = Math.min(originalWidth, maxWidth);
                newHeight = newWidth / aspectRatio;
              } else {
                newHeight = Math.min(originalHeight, maxHeight);
                newWidth = newHeight * aspectRatio;
              }
              
              console.log('[압축] 크기 조정:', `${originalWidth}x${originalHeight} → ${Math.round(newWidth)}x${Math.round(newHeight)}`);
            }
            
            // Canvas 크기 설정
            canvas.width = Math.round(newWidth);
            canvas.height = Math.round(newHeight);
            
            // 이미지를 Canvas에 그리기 (고품질 스케일링)
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // 압축된 이미지 데이터 생성
            const compressedDataUrl = canvas.toDataURL(outputFormat, quality);
            
            // 압축된 크기 계산 (base64 데이터 크기)
            const compressedSize = Math.round((compressedDataUrl.length * 3) / 4);
            const compressionRatio = ((1 - compressedSize / file.size) * 100).toFixed(1);
            
            console.log('[압축] 압축 완료:', 
              `압축후: ${(compressedSize/1024).toFixed(2)}KB`,
              `압축률: ${compressionRatio}%`,
              `품질: ${quality}`
            );
            
            resolve({
              dataUrl: compressedDataUrl,
              size: compressedSize,
              originalSize: file.size,
              compressionRatio: parseFloat(compressionRatio),
              dimensions: {
                original: { width: originalWidth, height: originalHeight },
                compressed: { width: canvas.width, height: canvas.height }
              }
            });
            
          } catch (error) {
            console.error('[압축] 이미지 압축 실패:', error);
            // 압축 실패 시 원본 파일 사용
            const reader = new FileReader();
            reader.onload = (e) => {
              resolve({
                dataUrl: e.target.result,
                size: file.size,
                originalSize: file.size,
                compressionRatio: 0,
                dimensions: null
              });
            };
            reader.readAsDataURL(file);
          }
        };
        
        img.onerror = function() {
          console.error('[압축] 이미지 로드 실패:', file.name);
          reject(new Error('이미지 로드 실패'));
        };
        
        // 이미지 로드 시작
        const reader = new FileReader();
        reader.onload = (e) => {
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      });
    }
    
    // 전역 스코프에 함수 할당
    window.optimizeImage = optimizeImage;

    /* ===== 이미지 확대 보기 모달 시스템 ===== */
    
    /**
     * 이미지 확대 보기 모달을 생성하고 표시합니다
     * @param {string} imageSrc - 확대할 이미지 URL
     * @param {string} alt - 이미지 alt 텍스트 (선택)
     */
    function showImageModal(imageSrc, alt = '') {
      console.log('[모달] 이미지 확대 모달 열기:', imageSrc);
      
      // 기존 모달이 있다면 제거
      const existingModal = document.getElementById('imageModal');
      if (existingModal) {
        existingModal.remove();
      }
      
      // 모달 HTML 생성
      const modalHTML = `
        <div id="imageModal" class="image-modal" style="
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.9);
          z-index: 10000;
          display: flex;
          align-items: center;
          justify-content: center;
          opacity: 0;
          transition: opacity 0.3s ease;
        ">
          <div class="modal-content" style="
            position: relative;
            max-width: 90vw;
            max-height: 90vh;
            text-align: center;
          ">
            <img id="modalImage" src="${imageSrc}" alt="${alt}" style="
              max-width: 100%;
              max-height: 100%;
              object-fit: contain;
              border-radius: 8px;
              box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            ">
            <button id="closeModal" style="
              position: absolute;
              top: -15px;
              right: -15px;
              width: 40px;
              height: 40px;
              border: none;
              border-radius: 50%;
              background: rgba(255, 255, 255, 0.9);
              color: #333;
              font-size: 20px;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              font-weight: bold;
              transition: all 0.2s ease;
              box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            " onmouseover="this.style.background='#fff'; this.style.transform='scale(1.1)'" 
               onmouseout="this.style.background='rgba(255, 255, 255, 0.9)'; this.style.transform='scale(1)'">
              ×
            </button>
            <div class="image-info" style="
              position: absolute;
              bottom: -40px;
              left: 50%;
              transform: translateX(-50%);
              background: rgba(0, 0, 0, 0.8);
              color: white;
              padding: 8px 12px;
              border-radius: 4px;
              font-size: 12px;
              white-space: nowrap;
            " id="imageInfo">
              ${alt || '이미지 보기'}
            </div>
          </div>
        </div>
      `;
      
      // 모달을 body에 추가
      document.body.insertAdjacentHTML('beforeend', modalHTML);
      
      const modal = document.getElementById('imageModal');
      const modalImage = document.getElementById('modalImage');
      const closeBtn = document.getElementById('closeModal');
      
      // 모달 닫기 함수
      function closeModal() {
        console.log('[모달] 이미지 모달 닫기');
        modal.style.opacity = '0';
        setTimeout(() => {
          if (modal.parentNode) {
            modal.remove();
          }
        }, 300);
      }
      
      // 이벤트 리스너 추가
      closeBtn.addEventListener('click', closeModal);
      
      // 모달 배경 클릭 시 닫기
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeModal();
        }
      });
      
      // ESC 키로 모달 닫기
      const escHandler = (e) => {
        if (e.key === 'Escape') {
          closeModal();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
      
      // 이미지 로드 완료 후 페이드인 효과
      modalImage.onload = () => {
        // 이미지 정보 업데이트
        const imageInfo = document.getElementById('imageInfo');
        if (imageInfo && modalImage.naturalWidth && modalImage.naturalHeight) {
          imageInfo.textContent = `${modalImage.naturalWidth} × ${modalImage.naturalHeight}`;
        }
        
        // 페이드인 애니메이션
        requestAnimationFrame(() => {
          modal.style.opacity = '1';
        });
      };
      
      // 이미지 로드 실패 시 처리
      modalImage.onerror = () => {
        console.error('[모달] 이미지 로드 실패:', imageSrc);
        closeModal();
      };
    }
    
    /**
     * 메시지 영역의 이미지에 클릭 이벤트를 바인딩합니다
     */
    function bindImageZoomEvents() {
      console.log('[모달] 이미지 확대 이벤트 바인딩 시작');
      
      // 이벤트 위임을 사용하여 동적으로 추가되는 이미지에도 적용
      document.addEventListener('click', (e) => {
        // 메시지 영역 내의 이미지 클릭 확인 (실제 메시지 컨테이너 사용)
        if (e.target.tagName === 'IMG' && e.target.closest('.messages-container')) {
          // 이미지 미리보기나 시스템 이미지는 제외
          if (e.target.classList.contains('profile-img') || 
              e.target.classList.contains('emoji') || 
              e.target.classList.contains('pavatar') ||
              e.target.classList.contains('avatar') ||
              e.target.id === 'defaultProfileImg') {
            return;
          }
          
          console.log('[모달] 메시지 이미지 클릭 감지:', e.target.src);
          
          // 클릭 시 확대 모달 표시
          showImageModal(e.target.src, e.target.alt || '채팅 이미지');
          
          // 기본 이벤트 중단 (링크 등의 동작 방지)
          e.preventDefault();
          e.stopPropagation();
        }
      });
      
      console.log('[모달] 이미지 확대 이벤트 바인딩 완료');
    }
    
    // 전역 스코프에 함수 할당
    window.showImageModal = showImageModal;
    window.bindImageZoomEvents = bindImageZoomEvents;

    /* ===== 프로필 편집 모달 시스템 ===== */
    class ProfileEditModal {
      constructor() {
        this.modal = null;
        this.uppy = null;
        this.currentImage = null;
        this.isUploading = false;
        this.selectedFile = null; // 기본 파일 업로드용
        
        this.init();
      }

      init() {
        console.log('🛠️ ProfileEditModal 초기화 시작');
        
        // DOM 요소 바인딩
        this.bindElements();
        
        // 이벤트 리스너 설정
        this.bindEvents();
        
        // Uppy 초기화 (지연)
        this.initUppy();
        
        console.log('✅ ProfileEditModal 초기화 완료');
      }

      bindElements() {
        try {
          console.log('🔗 ProfileEditModal 요소 바인딩 시작');
          
          // 필수 요소들을 안전하게 바인딩
          const requiredElements = {
            modal: 'profileEditModal',
            currentProfileImg: 'currentProfileImg',
            changeImageBtn: 'changeImageBtn',
            imageUploadArea: 'imageUploadArea',
            editNickname: 'editNickname',
            editStatusMessage: 'editStatusMessage',
            nicknameCount: 'nicknameCount',
            statusCount: 'statusCount'
          };

          const missingElements = [];

          for (const [property, elementId] of Object.entries(requiredElements)) {
            const element = document.getElementById(elementId);
            this[property] = element;
            
            if (!element) {
              missingElements.push(elementId);
              console.warn(`⚠️ ProfileEditModal: ${elementId} 요소를 찾을 수 없습니다`);
            }
          }

          if (missingElements.length > 0) {
            throw new Error(`필수 요소들을 찾을 수 없습니다: ${missingElements.join(', ')}`);
          }

          console.log('✅ ProfileEditModal 요소 바인딩 완료');
        } catch (error) {
          console.error('❌ ProfileEditModal 요소 바인딩 실패:', error);
          throw error;
        }
      }

      bindEvents() {
        try {
          console.log('🎯 ProfileEditModal 이벤트 바인딩 시작');
          
          // 닉네임 글자 수 카운터 - null 체크 포함
          if (this.editNickname && this.nicknameCount) {
            this.editNickname.addEventListener('input', (e) => {
              const count = e.target.value.length;
              this.nicknameCount.textContent = count;
              if (count > 20) {
                e.target.value = e.target.value.substring(0, 20);
                this.nicknameCount.textContent = 20;
              }
            });
          } else {
            console.warn('⚠️ 닉네임 카운터 바인딩 실패');
          }

          // 상태 메시지 글자 수 카운터 - null 체크 포함
          if (this.editStatusMessage && this.statusCount) {
            this.editStatusMessage.addEventListener('input', (e) => {
              const count = e.target.value.length;
              this.statusCount.textContent = count;
              if (count > 50) {
                e.target.value = e.target.value.substring(0, 50);
                this.statusCount.textContent = 50;
              }
            });
          } else {
            console.warn('⚠️ 상태 메시지 카운터 바인딩 실패');
          }

          // 이미지 변경 버튼 - null 체크 포함
          if (this.changeImageBtn) {
            this.changeImageBtn.addEventListener('click', () => {
              try {
                this.toggleImageUpload();
              } catch (error) {
                console.error('🖼️ 이미지 토글 실패:', error);
              }
            });
          } else {
            console.warn('⚠️ 이미지 변경 버튼 바인딩 실패');
          }

          // 모달 외부 클릭 시 닫기 - null 체크 포함
          if (this.modal) {
            this.modal.addEventListener('click', (e) => {
              if (e.target === this.modal) {
                try {
                  this.close();
                } catch (error) {
                  console.error('❌ 모달 닫기 실패:', error);
                }
              }
            });
          } else {
            console.warn('⚠️ 모달 외부 클릭 바인딩 실패');
          }

          // ESC 키로 모달 닫기 - 전역 이벤트이므로 항상 바인딩
          document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.isOpen()) {
              try {
                this.close();
              } catch (error) {
                console.error('❌ ESC 키 모달 닫기 실패:', error);
              }
            }
          });

          console.log('✅ ProfileEditModal 이벤트 바인딩 완료');
        } catch (error) {
          console.error('❌ ProfileEditModal 이벤트 바인딩 실패:', error);
          throw error;
        }
      }

      initUppy() {
        console.log('🚀 파일 업로드 시스템 초기화 시작...');
        
        // Uppy.js 사용 시도
        if (typeof Uppy !== 'undefined') {
          try {
            console.log('📦 Uppy.js 사용 가능, 고급 업로드 시스템 초기화 중...');
            this.initUppyAdvanced();
            return;
          } catch (error) {
            console.error('❌ Uppy.js 초기화 실패:', error);
            console.log('🔄 기본 파일 업로드 시스템으로 전환...');
          }
        } else {
          console.warn('⚠️ Uppy.js가 로드되지 않았습니다.');
          console.log('🔄 기본 파일 업로드 시스템으로 전환...');
        }
        
        // 기본 HTML5 파일 업로드 시스템으로 fallback
        this.initBasicFileUpload();
      }

      initUppyAdvanced() {
        // Uppy 생성자 안전성 검사
        if (typeof Uppy !== 'function' && typeof Uppy.Core !== 'function') {
          throw new Error('Uppy 생성자를 찾을 수 없습니다');
        }
        
        // Uppy 인스턴스 생성 (Core 또는 기본 생성자 사용)
        const UppyConstructor = typeof Uppy === 'function' ? Uppy : Uppy.Core;
        this.uppy = new UppyConstructor({
          restrictions: {
            maxFileSize: 5 * 1024 * 1024, // 5MB
            maxNumberOfFiles: 1,
            allowedFileTypes: ['image/*']
          },
          locale: {
            strings: {
              dropPasteImport: '이미지를 드래그하거나 붙여넣기하세요',
              browseFiles: '파일 선택',
              cancel: '취소',
              done: '완료'
            }
          }
        });

        // Dashboard 플러그인 안전 사용
        const DashboardPlugin = Uppy.Dashboard || (window.Uppy && window.Uppy.Dashboard);
        if (DashboardPlugin) {
          this.uppy.use(DashboardPlugin, {
            target: '#uppyDashboard',
            inline: true,
            width: '100%',
            height: 200,
            showProgressDetails: true,
            hideUploadButton: false,
            hideRetryButton: true,
            hidePauseResumeButton: true,
            hideCancelButton: false,
            showRemoveButtonAfterComplete: true,
            note: 'JPG, PNG, GIF 파일만 업로드 가능 (최대 5MB)'
          });
        }

        // ImageEditor 플러그인 안전 사용 (선택적)
        const ImageEditorPlugin = Uppy.ImageEditor || (window.Uppy && window.Uppy.ImageEditor);
        if (ImageEditorPlugin && DashboardPlugin) {
          this.uppy.use(ImageEditorPlugin, {
            target: DashboardPlugin,
            quality: 0.8
          });
        }

        // XHRUpload 플러그인 안전 사용
        const XHRUploadPlugin = Uppy.XHRUpload || (window.Uppy && window.Uppy.XHRUpload);
        if (XHRUploadPlugin) {
          this.uppy.use(XHRUploadPlugin, {
            endpoint: '/api/profile-upload',
            method: 'POST',
            formData: true,
            fieldName: 'image',
            getResponseData: (responseText) => {
              const response = JSON.parse(responseText);
              return {
                url: response.url,
                success: response.success
              };
            },
            addMetadata: true
          });
        }

        // 이벤트 핸들러
        this.uppy.on('upload', () => {
          if (AppState.userId) {
            this.uppy.setMeta({ userId: AppState.userId });
          }
        });

        this.uppy.on('file-added', (file) => {
          console.log('📁 파일 선택됨:', file.name);
          this.previewImage(file);
        });

        this.uppy.on('file-removed', (file) => {
          console.log('🗑️ 파일 제거됨:', file.name);
          this.resetImagePreview();
        });

        this.uppy.on('upload-success', (file, response) => {
          console.log('✅ 파일 업로드 성공:', response);
          this.currentImage = response.uploadURL || response.body.url;
        });

        this.uppy.on('upload-error', (file, error) => {
          console.error('❌ 파일 업로드 실패:', error);
          alert('파일 업로드에 실패했습니다. 다시 시도해주세요.');
        });

        console.log('✅ Uppy.js 고급 업로드 시스템 초기화 완료');
      }

      initBasicFileUpload() {
        console.log('🛠️ 기본 파일 업로드 시스템 초기화...');
        
        // 기본 파일 업로드 UI 생성
        const uploadArea = document.getElementById('imageUploadArea');
        if (!uploadArea) {
          console.error('❌ imageUploadArea를 찾을 수 없습니다');
          return;
        }

        // 기존 내용 지우고 기본 파일 업로드 UI 생성
        uploadArea.innerHTML = `
          <div class="basic-upload-container" style="
            border: 2px dashed var(--line, #e5e7eb);
            border-radius: var(--radius-md, 8px);
            padding: 24px;
            text-align: center;
            background: var(--panel, #f9fafb);
            transition: all 0.2s ease;
          ">
            <div class="upload-icon" style="font-size: 48px; margin-bottom: 12px;">📷</div>
            <h3 style="margin: 0 0 8px 0; color: var(--text, #374151);">프로필 사진 선택</h3>
            <p style="margin: 0 0 16px 0; color: var(--muted, #6b7280); font-size: 14px;">
              JPG, PNG, GIF 파일만 업로드 가능 (최대 5MB)
            </p>
            <input type="file" id="basicFileInput" accept="image/*" style="display: none;">
            <button type="button" id="selectFileBtn" style="
              background: var(--accent, #3b82f6);
              color: white;
              border: none;
              padding: 10px 20px;
              border-radius: var(--radius-sm, 6px);
              cursor: pointer;
              font-size: 14px;
              margin-right: 8px;
            ">파일 선택</button>
            <button type="button" id="clearFileBtn" style="
              background: var(--muted, #6b7280);
              color: white;
              border: none;
              padding: 10px 20px;
              border-radius: var(--radius-sm, 6px);
              cursor: pointer;
              font-size: 14px;
              display: none;
            ">선택 취소</button>
            <div id="filePreview" style="margin-top: 16px; display: none;">
              <img id="previewImage" style="max-width: 200px; max-height: 200px; border-radius: var(--radius-md, 8px);">
              <p id="fileName" style="margin: 8px 0 0 0; font-size: 12px; color: var(--muted, #6b7280);"></p>
            </div>
          </div>
        `;

        // 이벤트 리스너 바인딩
        const fileInput = document.getElementById('basicFileInput');
        const selectBtn = document.getElementById('selectFileBtn');
        const clearBtn = document.getElementById('clearFileBtn');
        const preview = document.getElementById('filePreview');
        const previewImg = document.getElementById('previewImage');
        const fileName = document.getElementById('fileName');

        if (!fileInput || !selectBtn || !clearBtn) {
          console.error('❌ 기본 업로드 UI 요소 생성 실패');
          return;
        }

        // 파일 선택 버튼 클릭
        selectBtn.addEventListener('click', () => {
          console.log('📂 파일 선택 버튼 클릭됨');
          fileInput.click();
        });

        // 파일 선택됨
        fileInput.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (!file) return;

          console.log('📁 기본 파일 선택됨:', file.name, `(${(file.size / 1024 / 1024).toFixed(2)}MB)`);

          // 파일 크기 검사
          if (file.size > 5 * 1024 * 1024) {
            alert('파일 크기는 5MB 이하여야 합니다.');
            fileInput.value = '';
            return;
          }

          // 파일 타입 검사
          if (!file.type.startsWith('image/')) {
            alert('이미지 파일만 업로드할 수 있습니다.');
            fileInput.value = '';
            return;
          }

          // 선택된 파일 저장
          this.selectedFile = file;

          // 미리보기 표시
          const reader = new FileReader();
          reader.onload = (e) => {
            previewImg.src = e.target.result;
            fileName.textContent = file.name;
            preview.style.display = 'block';
            clearBtn.style.display = 'inline-block';
            
            // 프로필 이미지 미리보기 업데이트
            if (this.currentProfileImg) {
              this.currentProfileImg.src = e.target.result;
              console.log('🖼️ 프로필 이미지 미리보기 업데이트 완료');
            }
          };
          reader.readAsDataURL(file);
        });

        // 선택 취소 버튼
        clearBtn.addEventListener('click', () => {
          console.log('🗑️ 파일 선택 취소');
          fileInput.value = '';
          this.selectedFile = null;
          preview.style.display = 'none';
          clearBtn.style.display = 'none';
          this.resetImagePreview();
        });

        console.log('✅ 기본 파일 업로드 시스템 초기화 완료');
      }

      async uploadSelectedFile(file) {
        if (!file) {
          console.error('❌ 업로드할 파일이 없습니다');
          return null;
        }

        try {
          console.log('🚀 기본 파일 업로드 시작:', file.name);

          // FormData 객체 생성
          const formData = new FormData();
          formData.append('image', file);
          
          if (AppState.userId) {
            formData.append('userId', AppState.userId);
          }

          // 서버에 파일 업로드
          const response = await fetch('/api/profile-upload', {
            method: 'POST',
            body: formData
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const result = await response.json();
          console.log('📤 기본 파일 업로드 서버 응답:', result);

          if (result.success && result.url) {
            console.log('✅ 기본 파일 업로드 성공:', result.url);
            return result;
          } else {
            throw new Error('서버 응답에 오류가 있습니다.');
          }

        } catch (error) {
          console.error('❌ 기본 파일 업로드 실패:', error);
          
          // 404 오류인 경우 base64 fallback 시도
          if (error.message.includes('404')) {
            console.log('🔄 Multer 업로드 실패, base64 방식으로 전환...');
            return await this.uploadFileAsBase64(file);
          }
          
          throw error;
        }
      }

      // Base64 방식 파일 업로드 (Multer 대안)
      async uploadFileAsBase64(file) {
        try {
          console.log('📋 Base64 파일 업로드 시작:', file.name);
          
          // 파일을 base64로 변환
          const base64Data = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(file);
          });
          
          console.log('🔄 파일을 base64로 변환 완료');
          
          // 서버에 base64 데이터 전송
          const response = await fetch('/api/profile-upload-temp', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              userId: AppState.userId,
              imageData: base64Data,
              fileName: file.name,
              fileSize: file.size
            })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const result = await response.json();
          console.log('📤 Base64 업로드 서버 응답:', result);
          
          if (result.success && result.url) {
            console.log('✅ Base64 파일 업로드 성공:', result.url);
            return result;
          } else {
            throw new Error('Base64 업로드 서버 응답에 오류가 있습니다.');
          }
          
        } catch (error) {
          console.error('❌ Base64 파일 업로드 실패:', error);
          throw error;
        }
      }

      open() {
        if (!this.modal) return;

        console.log('🔓 프로필 편집 모달 열기');
        
        // 현재 프로필 정보 로드
        this.loadCurrentProfile();
        
        // 모달 표시
        this.modal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        
        // 첫 번째 입력 필드에 포커스
        setTimeout(() => {
          this.editNickname.focus();
        }, 100);
      }

      close() {
        if (!this.modal) return;

        console.log('🔒 프로필 편집 모달 닫기');
        
        // 업로드 영역 숨기기
        this.hideImageUpload();
        
        // Uppy 리셋
        if (this.uppy) {
          this.uppy.reset();
        }
        
        // 기본 파일 업로드 리셋
        this.selectedFile = null;
        
        // 모달 숨기기
        this.modal.style.display = 'none';
        document.body.style.overflow = '';
      }

      isOpen() {
        return this.modal && this.modal.style.display === 'flex';
      }

      loadCurrentProfile() {
        // 현재 사용자 정보를 모달에 로드
        if (AppState.me) {
          this.editNickname.value = AppState.me.nickname || '';
          this.editStatusMessage.value = AppState.me.status || '';
          
          // 글자 수 카운터 업데이트
          this.nicknameCount.textContent = this.editNickname.value.length;
          this.statusCount.textContent = this.editStatusMessage.value.length;
          
          // 프로필 이미지 설정
          const profileImg = AppState.me.avatar || '/favicon.ico';
          this.currentProfileImg.src = profileImg;
          this.currentProfileImg.alt = `${AppState.me.nickname}님의 프로필`;
          
          this.currentImage = AppState.me.avatar;
        }
      }

      toggleImageUpload() {
        console.log('🔄 이미지 업로드 토글 실행');
        
        if (!this.imageUploadArea) {
          console.error('❌ imageUploadArea 요소를 찾을 수 없습니다');
          return;
        }
        
        try {
          const isVisible = this.imageUploadArea.style.display !== 'none' && this.imageUploadArea.style.display !== '';
          
          console.log(`📋 현재 이미지 업로드 영역 상태: ${isVisible ? '표시됨' : '숨겨짐'}`);
          
          if (isVisible) {
            this.hideImageUpload();
          } else {
            this.showImageUpload();
          }
        } catch (error) {
          console.error('❌ 이미지 업로드 토글 중 오류 발생:', error);
        }
      }

      showImageUpload() {
        console.log('👆 이미지 업로드 영역 표시');
        
        if (!this.imageUploadArea) {
          console.error('❌ imageUploadArea가 null입니다');
          return;
        }
        
        try {
          this.imageUploadArea.style.display = 'block';
          console.log('✅ 이미지 업로드 영역 표시 완료');
          
          // Uppy Dashboard 크기 조정
          if (this.uppy) {
            setTimeout(() => {
              try {
                const dashboard = this.uppy.getPlugin('Dashboard');
                if (dashboard && dashboard.requestCloseModal) {
                  dashboard.requestCloseModal();
                }
              } catch (uppyError) {
                console.warn('⚠️ Uppy Dashboard 조정 실패:', uppyError);
              }
            }, 100);
          }
        } catch (error) {
          console.error('❌ 이미지 업로드 영역 표시 실패:', error);
        }
      }

      hideImageUpload() {
        console.log('👇 이미지 업로드 영역 숨김');
        
        if (!this.imageUploadArea) {
          console.error('❌ imageUploadArea가 null입니다');
          return;
        }
        
        try {
          this.imageUploadArea.style.display = 'none';
          console.log('✅ 이미지 업로드 영역 숨김 완료');
        } catch (error) {
          console.error('❌ 이미지 업로드 영역 숨김 실패:', error);
        }
      }

      previewImage(file) {
        // File 객체를 이용해 미리보기 생성
        const reader = new FileReader();
        reader.onload = (e) => {
          this.currentProfileImg.src = e.target.result;
        };
        reader.readAsDataURL(file.data);
      }

      resetImagePreview() {
        // 원본 프로필 이미지로 복원
        if (AppState.me) {
          this.currentProfileImg.src = AppState.me.avatar || '/favicon.ico';
        }
        this.currentImage = AppState.me?.avatar || null;
      }

      // 저장 버튼 초기화 메서드
      resetSaveButton() {
        const saveBtn = document.querySelector('.btn-save');
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.innerHTML = '저장';
        }
      }

      async saveProfile() {
        if (this.isUploading) return;

        try {
          this.isUploading = true;
          console.log('💾 프로필 저장 시작');

          const saveBtn = document.querySelector('.btn-save');
          if (saveBtn) {
            saveBtn.disabled = true;
            saveBtn.innerHTML = '<div class="spinner"></div> 저장 중...';
          }

          // 업데이트할 프로필 데이터
          const profileData = {
            nickname: this.editNickname.value.trim(),
            status: this.editStatusMessage.value.trim()
          };

          // 이미지 업로드 처리 (Uppy 또는 기본 파일 업로드)
          if (this.uppy && this.uppy.getFiles().length > 0) {
            console.log('📤 Uppy 이미지 업로드 중...');
            
            // Uppy를 이용한 파일 업로드
            const result = await this.uppy.upload();
            
            if (result.successful && result.successful.length > 0) {
              // 업로드 성공 시 response에서 URL 가져오기
              const uploadedFile = result.successful[0];
              const response = uploadedFile.response ? uploadedFile.response.body : null;
              
              if (response && response.url) {
                profileData.avatar = response.url;
                console.log('✅ Uppy 이미지 업로드 완료:', profileData.avatar);
                
                // 이미지가 업로드된 경우 AppState와 UI를 바로 업데이트
                AppState.me = { ...AppState.me, avatar: response.url };
              }
            } else if (result.failed && result.failed.length > 0) {
              throw new Error('이미지 업로드에 실패했습니다.');
            }
          } else if (this.selectedFile) {
            console.log('📤 기본 파일 업로드 중...', this.selectedFile.name);
            
            // 기본 파일 업로드 시스템 사용 (Multer 및 Base64 fallback 포함)
            const uploadResult = await this.uploadSelectedFile(this.selectedFile);
            
            if (uploadResult && uploadResult.success) {
              profileData.avatar = uploadResult.url;
              console.log('✅ 파일 업로드 완료:', profileData.avatar);
              
              // 이미지가 업로드된 경우 AppState와 UI를 바로 업데이트 (Multer와 Base64 둘 다 처리)
              AppState.me = { ...AppState.me, avatar: uploadResult.url };
            } else {
              throw new Error('이미지 업로드에 실패했습니다.');
            }
          } else if (this.currentImage !== AppState.me?.avatar) {
            // 이미지가 변경되었지만 새 파일이 없는 경우 (기존 이미지 유지 또는 제거)
            profileData.avatar = this.currentImage;
          }

          // 닉네임, 상태메시지, 아바타 변경사항 확인
          const hasNicknameChange = profileData.nickname !== (AppState.me?.nickname || '');
          const hasStatusChange = profileData.status !== (AppState.me?.status || '');
          const hasAvatarChange = profileData.avatar !== (AppState.me?.avatar || AppState.me?.profileImage);
          
          if (hasNicknameChange || hasStatusChange || hasAvatarChange) {
            console.log('📝 프로필 정보 업데이트 중...');
            await this.updateProfile(profileData);
          } else {
            console.log('ℹ️ 변경된 프로필 정보가 없습니다.');
            // UI만 업데이트
            updateProfileUI();
          }
          
          // 성공적으로 저장되면 모달 닫기
          console.log('✅ 프로필 저장 완료');
          
          // 버튼 상태 먼저 초기화
          this.resetSaveButton();
          
          // 약간의 지연 후 모달 닫기 (사용자가 성공 상태를 볼 수 있도록)
          setTimeout(() => {
            this.close();
          }, 200);

        } catch (error) {
          console.error('❌ 프로필 저장 실패:', error);
          alert('프로필 저장에 실패했습니다. 다시 시도해주세요.');
          
          // 에러 발생 시에도 버튼 초기화
          this.resetSaveButton();
        } finally {
          this.isUploading = false;
        }
      }

      async updateProfile(profileData) {
        return new Promise((resolve, reject) => {
          // 기존 프로필 업데이트 로직 재사용
          if (!socket || !socket.connected) {
            reject(new Error('서버 연결이 끊어졌습니다.'));
            return;
          }

          // 소켓을 통한 프로필 업데이트
          socket.emit('updateProfile', {
            userId: AppState.userId,
            ...profileData
          });

          // 응답 대기
          const timeout = setTimeout(() => {
            reject(new Error('서버 응답 시간 초과'));
          }, 10000);

          const onProfileUpdateResponse = (response) => {
            clearTimeout(timeout);
            socket.off('profileUpdateResponse', onProfileUpdateResponse);
            
            if (response.success) {
              // AppState 업데이트
              AppState.me = { ...AppState.me, ...profileData };
              
              // UI 업데이트
              updateProfileUI();
              
              resolve(response);
            } else {
              reject(new Error(response.error || '프로필 업데이트 실패'));
            }
          };

          socket.on('profileUpdateResponse', onProfileUpdateResponse);
        });
      }
    }

    // 전역 프로필 편집 모달 인스턴스
    let profileEditModal = null;

    // 모달 제어 함수들 (HTML에서 호출)
    function openProfileEditModal() {
      if (!profileEditModal) {
        profileEditModal = new ProfileEditModal();
      }
      profileEditModal.open();
    }

    function openProfileEdit() {
      openProfileEditModal();
    }

    function closeProfileEditModal() {
      if (profileEditModal) {
        profileEditModal.close();
      }
    }

    // Work Status Functions
    function openWorkStatusSelector() {
      const modal = document.getElementById('workStatusModal');
      if (modal) {
        // 선택된 상태를 현재 상태로 초기화
        selectedWorkStatus = currentWorkStatus;
        
        modal.style.display = 'grid';
        
        // Prevent body scroll on mobile
        document.body.style.overflow = 'hidden';
        
        // 선택 상태 UI 업데이트
        updateWorkStatusSelection();
      }
    }

    function closeWorkStatusSelector() {
      const modal = document.getElementById('workStatusModal');
      if (modal) {
        modal.style.display = 'none';
        // Restore body scroll
        document.body.style.overflow = '';
      }
    }

    // 임시 선택 함수 (저장하지 않고 선택만)
    function selectWorkStatusTemp(status) {
      selectedWorkStatus = status;
      updateWorkStatusSelection();
      console.log(`🔄 임시 업무 상태 선택: ${status}`);
    }

    // 업무 상태 선택 UI 업데이트
    function updateWorkStatusSelection() {
      const buttons = document.querySelectorAll('.status-option');
      buttons.forEach(btn => {
        const btnStatus = btn.dataset.status;
        if (btnStatus === selectedWorkStatus) {
          btn.classList.add('selected');
        } else {
          btn.classList.remove('selected');
        }
      });
    }

    // 업무 상태 변경 저장
    function saveWorkStatusChange() {
      const previousStatus = currentWorkStatus;
      currentWorkStatus = selectedWorkStatus;
      updateWorkStatusDisplay();
      closeWorkStatusSelector();
      
      // Save to localStorage
      if (window.localStorage) {
        localStorage.setItem('workStatus', currentWorkStatus);
      }
      
      // Send to server via Socket.IO
      if (socket && socket.connected) {
        console.log(`🔄 서버로 업무 상태 변경 전송: ${previousStatus} → ${currentWorkStatus}`);
        socket.emit('updateWorkStatus', {
          status: currentWorkStatus,
          timestamp: Date.now()
        });
      } else {
        console.warn('⚠️ 소켓이 연결되지 않아 업무 상태를 서버에 전송할 수 없습니다');
        console.warn(`🔍 소켓 상태: socket=${!!socket}, connected=${socket?.connected}`);
      }
    }

    // 업무 상태 변경 취소
    function cancelWorkStatusChange() {
      selectedWorkStatus = currentWorkStatus; // 선택을 현재 상태로 되돌림
      updateWorkStatusSelection();
      closeWorkStatusSelector();
      console.log(`🔄 업무 상태 변경 취소됨`);
    }

    // 기존 selectWorkStatus 함수 (하위 호환성)
    function selectWorkStatus(status) {
      selectWorkStatusTemp(status);
      saveWorkStatusChange();
    }

    function updateWorkStatusDisplay() {
      const status = WorkStatus[currentWorkStatus] || WorkStatus.offline;
      
      // Update header work status
      const headerWorkStatus = document.getElementById('headerWorkStatus');
      if (headerWorkStatus) {
        headerWorkStatus.textContent = status.text;
      }
      
      // Update work status dot
      const headerStatusDot = document.getElementById('headerStatusDot');
      if (headerStatusDot) {
        headerStatusDot.className = 'work-status-dot ' + currentWorkStatus;
      }
      
      // Update dropdown status
      const dropdownStatus = document.getElementById('dropdownStatus');
      if (dropdownStatus) {
        dropdownStatus.textContent = status.text;
      }
      
      // Update sidebar work status
      const sidebarStatusIcon = document.getElementById('sidebarStatusIcon');
      const sidebarStatusText = document.getElementById('sidebarStatusText');
      if (sidebarStatusIcon) sidebarStatusIcon.textContent = status.icon;
      if (sidebarStatusText) sidebarStatusText.textContent = status.text;
      
      // Update status selector icon and text
      const statusIcon = document.getElementById('statusIcon');
      const statusText = document.getElementById('statusText');
      if (statusIcon) statusIcon.textContent = status.icon;
      if (statusText) statusText.textContent = `업무 상태: ${status.text}`;
      
      // Update modal work status
      updateModalWorkStatus();
    }

    function updateModalWorkStatus(targetUserId = null) {
      // 대상 사용자의 업무 상태 찾기
      let workStatusToShow = currentWorkStatus; // 기본값: 자신의 상태
      
      if (targetUserId && targetUserId !== AppState.userId) {
        // 다른 사용자의 프로필을 보는 경우, 접속자 목록에서 해당 사용자의 업무 상태 찾기
        const targetUser = AppState.connectedUsers.find(u => u.userId === targetUserId);
        if (targetUser && targetUser.workStatus) {
          workStatusToShow = targetUser.workStatus;
        } else {
          workStatusToShow = 'offline'; // 업무 상태가 없으면 오프라인으로 표시
        }
      }
      
      const status = WorkStatus[workStatusToShow] || WorkStatus.offline;
      
      // Update modal work status display
      const modalStatusIcon = document.getElementById('modalStatusIcon');
      const modalStatusText = document.getElementById('modalStatusText');
      const modalStatusDesc = document.getElementById('modalStatusDesc');
      
      if (modalStatusIcon) modalStatusIcon.textContent = status.icon;
      if (modalStatusText) modalStatusText.textContent = status.text;
      if (modalStatusDesc) modalStatusDesc.textContent = status.description || (status.text === '오프라인' ? '업무 종료' : '업무 중');
      
      console.log(`💼 모달 업무 상태 업데이트: ${targetUserId || 'self'} → ${workStatusToShow}`);
    }



    // Connected Users Modal Functions
    function openConnectedUsersModal() {
      const modal = document.getElementById('connectedUsersModal');
      if (modal) {
        renderMobileConnectedUsers();
        modal.style.display = 'grid';
        document.body.style.overflow = 'hidden';
      }
    }

    function closeConnectedUsersModal() {
      const modal = document.getElementById('connectedUsersModal');
      if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = '';
      }
    }

    function renderMobileConnectedUsers() {
      const container = document.getElementById('mobileConnectedUsersList');
      if (!container) return;

      const users = AppState.connectedUsers || [];
      const headerText = document.querySelector('#connectedUsersModal h3');
      if (headerText) {
        headerText.textContent = `현재 접속자 (${users.length})`;
      }

      if (users.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--muted);">접속자가 없습니다.</div>';
        return;
      }

      container.innerHTML = users.map(user => {
        const safeInitial = initialLetter(user.nickname || user.username || '');
        const workStatus = WorkStatus[user.workStatus || 'offline'] || WorkStatus.offline;
        
        const avatarHtml = user.avatar && user.avatar.trim() 
          ? `<img src="${user.avatar}" alt="${user.nickname}님의 프로필" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">`
          : '';
        
        const fallbackAvatarHtml = `<div style="display: ${user.avatar ? 'none' : 'flex'}; width: 100%; height: 100%; align-items: center; justify-content: center;">${safeInitial}</div>`;

        return `
          <div class="mobile-user-item" onclick="showProfileModal('${user.nickname || user.username}', '${user.avatar || ''}', '${user.status || ''}', '${user.userId}')">
            <div class="mobile-user-avatar">
              ${avatarHtml}
              ${fallbackAvatarHtml}
            </div>
            <div class="mobile-user-info">
              <div class="mobile-user-name">${user.nickname || user.username || 'Unknown'}</div>
              <div class="mobile-user-status">
                ${user.status || '상태메시지 없음'}
                <div class="mobile-work-status">
                  <span>${workStatus.icon}</span>
                  <span>${workStatus.text}</span>
                </div>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    // Settings function placeholder
    function openSettings() {
      alert('설정 기능은 준비 중입니다.');
    }

    // Initialize work status from localStorage
    function initializeWorkStatus() {
      if (window.localStorage) {
        const savedStatus = localStorage.getItem('workStatus');
        if (savedStatus && WorkStatus[savedStatus]) {
          currentWorkStatus = savedStatus;
        }
      }
      updateWorkStatusDisplay();
    }

    function saveProfileChanges() {
      if (profileEditModal) {
        profileEditModal.saveProfile();
      }
    }

    // 프로필 UI 업데이트 함수
    function updateProfileUI() {
      if (!AppState.me) return;
      
      // 사이드바 닉네임 업데이트
      const nicknameView = document.getElementById('nicknameView');
      if (nicknameView) {
        nicknameView.textContent = AppState.me.nickname || 'User';
      }
      
      // 헤더 프로필 정보 업데이트
      const headerName = document.getElementById('headerName');
      if (headerName) {
        headerName.textContent = AppState.me.nickname || AppState.me.username || 'User';
      }
      
      // 헤더 아바타 업데이트
      const headerAvatar = document.getElementById('headerAvatar');
      if (headerAvatar) {
        if (AppState.me.profileImage && AppState.me.profileImage.trim()) {
          headerAvatar.src = AppState.me.profileImage;
        } else if (AppState.me.avatar && AppState.me.avatar.trim()) {
          headerAvatar.src = AppState.me.avatar;
        } else {
          headerAvatar.src = '/favicon.ico'; // Default avatar
        }
      }
      
      // 사이드바 아바타 이미지 업데이트
      const avatarImg = document.getElementById('avatarImg');
      if (avatarImg) {
        if (AppState.me.profileImage && AppState.me.profileImage.trim()) {
          avatarImg.src = AppState.me.profileImage;
          avatarImg.style.visibility = 'visible';
        } else if (AppState.me.avatar && AppState.me.avatar.trim()) {
          avatarImg.src = AppState.me.avatar;
          avatarImg.style.visibility = 'visible';
        } else {
          avatarImg.removeAttribute('src');
          avatarImg.style.visibility = 'hidden';
        }
      }
      
      // 상태 메시지 업데이트
      const statusView = document.getElementById('statusView');
      if (statusView) {
        statusView.textContent = AppState.me.status || '상태메시지…';
      }
      
      // 접속자 목록에서 현재 사용자 아바타 업데이트
      if (AppState.userId && AppState.connectedUsers) {
        const currentUserIndex = AppState.connectedUsers.findIndex(u => u.userId === AppState.userId);
        if (currentUserIndex >= 0) {
          // 접속자 목록의 현재 사용자 정보 업데이트
          AppState.connectedUsers[currentUserIndex] = {
            ...AppState.connectedUsers[currentUserIndex],
            nickname: AppState.me.nickname || AppState.connectedUsers[currentUserIndex].nickname,
            avatar: AppState.me.avatar || AppState.me.profileImage || AppState.connectedUsers[currentUserIndex].avatar,
            status: AppState.me.status || AppState.connectedUsers[currentUserIndex].status
          };
          
          // 접속자 목록 다시 렌더링
          if (typeof ConnectedUsersUI !== 'undefined' && ConnectedUsersUI.render) {
            ConnectedUsersUI.render(AppState.connectedUsers);
          }
        }
      }
      
      console.log('✅ 프로필 UI 업데이트 완료');
    }
    
    // 전역 상태
    const AppState = {
      currentRoom: '주중',
      userId: null,
      me: null,
      isAdmin: false,  // 관리자 권한 플래그
      flags: {
        sending: false,
        uploading: false,
        switching: false  // 방 전환 중 플래그 추가
      },
      // 🔗 답글 상태 관리
      reply: {
        active: false,    // 답글 모드 활성화 여부
        targetMid: null,  // 답글 대상 메시지 ID
        targetNick: null  // 답글 대상 사용자명
      },
      cache: {
        renderedMids: { 
          '주중': new Map(), 
          '주말': new Map(), 
          '전체': new Map(), 
          '방문예정': new Map() 
        },
        lastTs: { '주중': 0, '주말': 0, '전체': 0, '방문예정': 0 },
        lastDayRendered: { '주중': '', '주말': '', '전체': '', '방문예정': '' },
        pagination: {},
        preloadedMessages: {}  // 🚀 프리로드된 메시지 캐시
      },
      connectedUsers: [], // 현재 접속자 목록
      // 🚀 방 방문 통계 및 프리로딩 설정
      roomStats: {
        visitCount: { '주중': 0, '주말': 0, '전체': 0, '방문예정': 0 },
        lastVisit: { '주중': 0, '주말': 0, '전체': 0, '방문예정': 0 },
        preloadThreshold: 3  // 3번 이상 방문한 방은 프리로드 대상
      },
      // 🔔 알림 시스템 상태
      notifications: {
        permission: 'default', // 'granted', 'denied', 'default'
        permissionRequested: false, // 권한 요청 여부 추적
        // 소리 설정 제거됨 - 기본값만 사용 (ding, 70% 볼륨)
        state: {
          isTabVisible: true,   // Page Visibility API 상태
          unreadCount: 0,       // 읽지 않은 메시지 수
          originalTitle: document.title, // 원래 타이틀 저장
          titleInterval: null   // 타이틀 깜빡임 인터벌
        }
      }
    };

    // Socket.io 연결 (지능형 Keep-Alive 설정)
    const socket = io({
      pingInterval: 25000,  // 25초마다 ping (Socket.IO v4 기본값)
      pingTimeout: 20000    // 20초 응답 타임아웃
    });

    /* ===== 🔔 NotificationQueue 클래스 ===== */
    class NotificationQueue {
      constructor() {
        this.activeNotifications = new Map();
        this.maxNotifications = 3; // 최대 동시 표시 가능한 알림 수
        this.cleanupInterval = null;
      }

      // 🔔 활성 알림 추가
      addNotification(tag, notificationRef) {
        this.activeNotifications.set(tag, {
          notification: notificationRef,
          timestamp: Date.now()
        });
        
        console.log(`📝 활성 알림 추가: ${tag} (총 ${this.activeNotifications.size}개)`);
        this.scheduleCleanup();
      }

      // 🔔 알림 제거
      removeNotification(tag) {
        if (this.activeNotifications.has(tag)) {
          this.activeNotifications.delete(tag);
          console.log(`🗑️ 활성 알림 제거: ${tag} (남은 ${this.activeNotifications.size}개)`);
        }
      }

      // 🔔 오래된 알림 자동 정리
      async cleanupOldNotifications() {
        const now = Date.now();
        const maxAge = 30000; // 30초 이상 된 알림 정리
        
        for (const [tag, data] of this.activeNotifications) {
          if (now - data.timestamp > maxAge) {
            try {
              if (data.notification && typeof data.notification.close === 'function') {
                data.notification.close();
              }
            } catch (error) {
              console.warn(`⚠️ 알림 정리 실패: ${tag}`, error);
            }
            this.removeNotification(tag);
          }
        }

        // 최대 개수 초과 시 오래된 것부터 제거
        if (this.activeNotifications.size > this.maxNotifications) {
          const sortedNotifications = Array.from(this.activeNotifications.entries())
            .sort((a, b) => a[1].timestamp - b[1].timestamp);
          
          const toRemove = sortedNotifications.slice(0, this.activeNotifications.size - this.maxNotifications);
          
          for (const [tag, data] of toRemove) {
            try {
              if (data.notification && typeof data.notification.close === 'function') {
                data.notification.close();
              }
            } catch (error) {
              console.warn(`⚠️ 초과 알림 정리 실패: ${tag}`, error);
            }
            this.removeNotification(tag);
          }
        }
      }

      // 🔔 정리 작업 스케줄링
      scheduleCleanup() {
        if (this.cleanupInterval) {
          clearTimeout(this.cleanupInterval);
        }
        
        this.cleanupInterval = setTimeout(() => {
          this.cleanupOldNotifications();
        }, 5000);
      }

      // 🔔 모든 알림 정리
      clearAll() {
        for (const [tag, data] of this.activeNotifications) {
          try {
            if (data.notification && typeof data.notification.close === 'function') {
              data.notification.close();
            }
          } catch (error) {
            console.warn(`⚠️ 전체 알림 정리 실패: ${tag}`, error);
          }
        }
        this.activeNotifications.clear();
        console.log('🧹 모든 활성 알림 정리 완료');
      }
    }

    /* ===== 🔔 NotificationManager 클래스 ===== */
    class NotificationManager {
      constructor() {
        this.audioContext = null;
        this.soundBuffers = new Map();
        this.isInitialized = false;
        
        // 🔔 알림 큐 관리자
        this.notificationQueue = new NotificationQueue();
        
        // 🔔 Push 구독 관련 속성
        this.pushSupported = false;
        this.subscription = null;
        this.serviceWorkerRegistration = null;
        this.vapidPublicKey = 'BG3zVpPIzzIaAkcJNu8gPIns8VcZXxVR4F0F30_qGPFAhJLtKhcMPEGP9Vh-j8VQxcdRrawnYlLP3i3NfsUzMYc';
        
        // 기본 사운드 URL들 (Data URL로 임베드된 소리들)
        this.soundUrls = {
          ding: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmEWAhqO2u7NfS0HLYnS9t2QQQ0PXrjs4ahWFQ1Bnt_y2mkzAhqO2u7NfS0HLYnS9t2QQQwPZLHl34RGAhqO2u7NfS0HLYnS9t2QQQwPZLHl34RHBAQR',
          pop: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmEWAhqO2u7NfS0HLYnS9t2QQQ0PXrjs4ahWFQ1Bnt_y2mkzAhqO2u7NfS0HLYnS9t2QQQwPZLHl34RGAhqO2u7NfS0HLYnS9t2QQQwPZLHl34RHBAQR',
          chime: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmEWAhqO2u7NfS0HLYnS9t2QQQ0PXrjs4ahWFQ1Bnt_y2mkzAhqO2u7NfS0HLYnS9t2QQQwPZLHl34RGAhqO2u7NfS0HLYnS9t2QQQwPZLHl34RHBAQR'
        };
      }

      // 🎵 Web Audio API 초기화 (사용자 제스처 후)
      async initializeAudio() {
        if (this.isInitialized) return true;
        
        try {
          // AudioContext 생성
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          
          // 사운드 버퍼 로드
          await this.loadSounds();
          
          this.isInitialized = true;
          console.log('🎵 Web Audio API 초기화 완료');
          return true;
        } catch (error) {
          console.error('❌ Web Audio API 초기화 실패:', error);
          return false;
        }
      }

      // 🔊 사운드 파일 로드
      async loadSounds() {
        for (const [type, dataUrl] of Object.entries(this.soundUrls)) {
          try {
            const response = await fetch(dataUrl);
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            this.soundBuffers.set(type, audioBuffer);
            console.log(`✅ ${type} 사운드 로드 성공`);
          } catch (error) {
            console.warn(`⚠️ ${type} 사운드 로드 실패:`, error.message || error);
            // 사운드 로드 실패해도 시스템은 계속 작동하도록 함
            this.soundBuffers.set(type, null);
          }
        }
        
        // 로드된 사운드 개수 로그
        const loadedCount = Array.from(this.soundBuffers.values()).filter(buffer => buffer !== null).length;
        const totalCount = Object.keys(this.soundUrls).length;
        console.log(`🎵 사운드 시스템: ${loadedCount}/${totalCount}개 로드 완료`);
      }

      // 🔔 알림 권한 요청
      async requestPermission() {
        if (!('Notification' in window)) {
          console.warn('⚠️ 이 브라우저는 알림을 지원하지 않습니다');
          return 'denied';
        }

        let permission = Notification.permission;
        
        if (permission === 'default') {
          permission = await Notification.requestPermission();
        }
        
        AppState.notifications.permission = permission;
        this.saveSettings();
        
        console.log(`🔔 알림 권한: ${permission}`);
        return permission;
      }

      // 🎵 사운드 재생
      playSound(type = null) {
        if (!this.isInitialized) return;
        
        const soundType = type || 'ding'; // 기본 소리
        const buffer = this.soundBuffers.get(soundType);
        
        if (!buffer || buffer === null) {
          console.debug(`🔇 ${soundType} 사운드 버퍼 없음 - 무음 재생`);
          return;
        }

        try {
          const source = this.audioContext.createBufferSource();
          const gainNode = this.audioContext.createGain();
          
          source.buffer = buffer;
          gainNode.gain.value = 0.7; // 기본 볼륨 70%
          
          source.connect(gainNode);
          gainNode.connect(this.audioContext.destination);
          
          source.start();
        } catch (error) {
          console.error('❌ 사운드 재생 실패:', error);
        }
      }

      // 🏷️ 탭 제목 알림 (깜빡임 효과)
      updateTabTitle(unreadCount = 0) {
        // 탭 제목 알림 (항상 활성화)
        
        const state = AppState.notifications.state;
        
        // 원래 제목이 설정되지 않았다면 현재 제목을 저장
        if (!state.originalTitle || state.originalTitle === '') {
          state.originalTitle = 'Eastalk (Web)';
        }
        
        console.log(`📋 탭 제목 업데이트: ${unreadCount}개 메시지, 탭 표시: ${state.isTabVisible}`);
        
        // 기존 인터벌 클리어
        if (state.titleInterval) {
          clearInterval(state.titleInterval);
          state.titleInterval = null;
        }
        
        if (unreadCount > 0) {
          const newMessage = `(${unreadCount}) ${state.originalTitle}`;
          
          // 즉시 제목 변경
          document.title = newMessage;
          
          // 탭이 비활성화되어 있을 때만 깜빡임 효과
          if (!state.isTabVisible) {
            let isShowingCount = true;
            
            state.titleInterval = setInterval(() => {
              // 탭이 활성화되면 깜빡임 중지하고 원래 제목으로 복원
              if (AppState.notifications.state.isTabVisible) {
                clearInterval(state.titleInterval);
                state.titleInterval = null;
                document.title = state.originalTitle;
                AppState.notifications.state.unreadCount = 0;
                return;
              }
              
              // 깜빡임: 카운트 표시 ↔ 원래 제목
              document.title = isShowingCount ? newMessage : state.originalTitle;
              isShowingCount = !isShowingCount;
            }, 800); // 800ms 간격으로 깜빡임
          }
        } else {
          // 읽지 않은 메시지가 없으면 원래 제목으로 복원
          document.title = state.originalTitle;
          state.unreadCount = 0;
        }
      }

      // 🔔 브라우저 알림 표시 (Push API와 기존 API 통합)
      showNotification(title, options = {}) {
        // 📊 상세 로깅 시작
        console.group('🔔 알림 표시 요청');
        console.log('제목:', title);
        console.log('옵션:', options);
        console.log('권한 상태:', AppState.notifications.permission);
        console.log('탭 가시성:', AppState.notifications.state.isTabVisible);
        console.log('활성 알림 수:', this.notificationQueue.activeNotifications.size);
        
        if (AppState.notifications.permission !== 'granted') {
          console.warn('⚠️ 알림 권한이 없어 알림을 표시할 수 없습니다');
          console.groupEnd();
          return;
        }

        // 스마트 모드: 탭이 활성화되어 있으면 알림 표시 안 함 (항상 활성)
        if (AppState.notifications.state.isTabVisible) {
          console.log('📋 탭이 활성화되어 있어 알림을 표시하지 않습니다');
          console.groupEnd();
          return;
        }

        // 🔔 고유 태그 생성으로 중복 알림 차단 문제 해결
        const uniqueTag = `eastalk-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        
        const defaultOptions = {
          icon: '/favicon.ico',
          badge: '/favicon.ico',
          tag: uniqueTag,
          renotify: true,  // 연속 알림 허용
          requireInteraction: false,
          silent: false,
          ...options
        };

        // Push API 지원 여부에 따라 처리 방식 결정
        console.log('🔧 Push API 지원:', this.pushSupported);
        console.log('🔧 Service Worker 등록:', !!this.serviceWorkerRegistration);
        
        if (this.pushSupported && this.serviceWorkerRegistration) {
          // Push API가 지원되는 경우: Service Worker를 통한 알림 표시
          console.log('📤 Service Worker를 통한 Push 알림 사용');
          this.showPushNotification(title, defaultOptions);
        } else {
          // 기존 방식: 직접 Notification API 사용
          console.log('📢 직접 Notification API 사용');
          this.showDirectNotification(title, defaultOptions);
        }
        
        console.groupEnd();
      }

      // 🔔 Service Worker를 통한 Push 알림 표시
      async showPushNotification(title, options) {
        try {
          if (!this.serviceWorkerRegistration) {
            console.warn('⚠️ Service Worker가 등록되지 않았습니다');
            this.showDirectNotification(title, options);
            return;
          }

          // 🔄 기존 알림 정리
          this.notificationQueue.cleanupOldNotifications();
          
          await this.serviceWorkerRegistration.showNotification(title, {
            ...options,
            renotify: true,  // 연속 알림 허용
            requireInteraction: false,
            actions: [
              {
                action: 'open',
                title: '열기'
              },
              {
                action: 'close', 
                title: '닫기'
              }
            ],
            data: {
              timestamp: Date.now(),
              source: 'eastalk-web',
              tag: options.tag
            }
          });

          console.log(`✅ Push 알림 표시됨 (Service Worker, Tag: ${options.tag})`);

        } catch (error) {
          console.error('❌ Push 알림 표시 실패:', error);
          // Fallback: 기존 방식 사용
          this.showDirectNotification(title, options);
        }
      }

      // 🔔 직접 Notification API를 통한 알림 표시
      showDirectNotification(title, options) {
        try {
          // 🔄 기존 알림 정리 (큐 관리자 사용)
          this.notificationQueue.cleanupOldNotifications();
          
          const notification = new Notification(title, options);
          const tag = options.tag || `eastalk-${Date.now()}`;
          
          // 🔔 알림 큐에 추가
          this.notificationQueue.addNotification(tag, notification);
          
          // 알림 클릭 시 창 포커스 및 큐에서 제거
          notification.onclick = () => {
            window.focus();
            this.notificationQueue.removeNotification(tag);
            notification.close();
            console.log('👆 알림 클릭됨 - 창 포커스');
          };
          
          // 알림 닫기 시 큐에서 제거
          notification.onclose = () => {
            this.notificationQueue.removeNotification(tag);
            console.log('❌ 알림 닫힘 - 큐에서 제거');
          };
          
          // 알림 오류 시 큐에서 제거
          notification.onerror = (error) => {
            this.notificationQueue.removeNotification(tag);
            console.error('❌ 알림 오류:', error);
          };
          
          // 자동 닫기 (10초 후로 연장)
          setTimeout(() => {
            this.notificationQueue.removeNotification(tag);
            notification.close();
          }, 10000);

          console.log(`✅ 직접 알림 표시됨 (Tag: ${tag})`);

        } catch (error) {
          console.error('❌ 직접 알림 표시 실패:', error);
        }
      }

      // 📨 새 메시지 알림 처리
      handleNewMessage(message, room) {
        // 자신이 보낸 메시지는 알림 안 함
        if (message.userId === AppState.userId) return;
        
        // 현재 방의 메시지이고 탭이 활성화되어 있으면 사운드만
        const isCurrentRoom = room === AppState.currentRoom;
        const isTabVisible = AppState.notifications.state.isTabVisible;
        
        if (isCurrentRoom && isTabVisible) {
          // 현재 방이고 탭이 보이면 사운드만
          this.playSound();
          return;
        }
        
        // 읽지 않은 메시지 수 증가
        AppState.notifications.state.unreadCount++;
        
        // 탭 제목 업데이트
        this.updateTabTitle(AppState.notifications.state.unreadCount);
        
        // 사운드 재생
        this.playSound();
        
        // 브라우저 알림 표시
        const roomText = room !== AppState.currentRoom ? ` [${room}]` : '';
        this.showNotification(`${message.nickname || message.name || '익명'}${roomText}`, {
          body: message.text || '이미지를 보냈습니다',
          icon: message.avatar || '/favicon.ico'
        });
      }

      // 🔧 설정 저장
      saveSettings() {
        try {
          localStorage.setItem('eastalk_notification_settings', JSON.stringify({
            permission: AppState.notifications.permission
          }));
        } catch (error) {
          console.error('❌ 알림 설정 저장 실패:', error);
        }
      }

      // 📥 설정 로드
      loadSettings() {
        try {
          const saved = localStorage.getItem('eastalk_notification_settings');
          if (saved) {
            const settings = JSON.parse(saved);
            // settings 제거됨 - 기본값 사용
            AppState.notifications.permission = settings.permission || 'default';
          }
        } catch (error) {
          console.error('❌ 알림 설정 로드 실패:', error);
        }
      }

      // 🎯 탭 활성화/비활성화 처리
      handleVisibilityChange() {
        const isVisible = !document.hidden;
        AppState.notifications.state.isTabVisible = isVisible;
        
        if (isVisible) {
          // 탭 활성화 시 읽지 않은 메시지 수 초기화
          AppState.notifications.state.unreadCount = 0;
          this.updateTabTitle(0);
        }
      }

      // 🔔 Push 지원 확인
      checkPushSupport() {
        if (!('serviceWorker' in navigator)) {
          console.warn('⚠️ Service Worker 미지원');
          return false;
        }
        
        if (!('PushManager' in window)) {
          console.warn('⚠️ Push Manager 미지원');
          return false;
        }
        
        if (!('Notification' in window)) {
          console.warn('⚠️ Notification API 미지원');
          return false;
        }
        
        this.pushSupported = true;
        console.log('✅ Push API 지원됨');
        return true;
      }

      // 🔧 Service Worker 등록
      async registerServiceWorker() {
        if (!this.pushSupported) return null;
        
        try {
          // Context7 표준: Service Worker 등록 후 ready 상태 대기
          const registration = await navigator.serviceWorker.register('/sw.js', {
            scope: '/' // 명시적 스코프 설정
          });
          console.log('✅ Service Worker 등록 성공:', registration.scope);
          
          // Service Worker가 완전히 활성화될 때까지 대기
          await navigator.serviceWorker.ready;
          console.log('✅ Service Worker 활성화 완료');
          
          // 기존 등록된 Service Worker 업데이트 확인
          if (registration.waiting) {
            console.log('🔄 Service Worker 업데이트 대기 중...');
            registration.waiting.postMessage({ type: 'SKIP_WAITING' });
          }
          
          this.serviceWorkerRegistration = registration;
          return registration;
        } catch (error) {
          console.error('❌ Service Worker 등록 실패:', error);
          
          // 구체적인 오류 진단
          if (error.name === 'SecurityError') {
            console.error('🚫 보안 오류: HTTPS 또는 localhost에서만 Service Worker 사용 가능');
          } else if (error.name === 'TypeError') {
            console.error('🚫 타입 오류: Service Worker 파일을 찾을 수 없음');
          }
          
          return null;
        }
      }

      // 📋 Base64 URL을 Uint8Array로 변환
      urlBase64ToUint8Array(base64String) {
        const padding = '='.repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding)
          .replace(/\-/g, '+')
          .replace(/_/g, '/');

        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);

        for (let i = 0; i < rawData.length; ++i) {
          outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
      }

      // 📱 Push 구독 생성
      async subscribeToPush(retryCount = 0) {
        if (!this.serviceWorkerRegistration) {
          console.warn('⚠️ Service Worker가 등록되지 않았습니다');
          return null;
        }

        try {
          // VAPID 공개키를 Uint8Array로 변환
          const applicationServerKey = this.urlBase64ToUint8Array(this.vapidPublicKey);
          
          console.log('📱 Push 구독 생성 시도...', retryCount > 0 ? `(재시도 ${retryCount}/3)` : '');
          
          // Push 구독 생성 (모바일 최적화)
          const subscription = await this.serviceWorkerRegistration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: applicationServerKey
          });

          console.log('✅ Push 구독 생성됨:', subscription);
          this.subscription = subscription;
          
          // 서버에 구독 정보 저장
          await this.sendSubscriptionToServer(subscription);
          
          return subscription;
        } catch (error) {
          console.error('❌ Push 구독 실패:', error);
          
          // 모바일에서 흔한 오류에 대한 재시도 로직
          if (retryCount < 3 && (
            error.name === 'NotSupportedError' ||
            error.name === 'NotAllowedError' ||
            error.message.includes('network')
          )) {
            console.log(`🔄 ${retryCount + 1}초 후 재시도...`);
            await new Promise(resolve => setTimeout(resolve, (retryCount + 1) * 1000));
            return this.subscribeToPush(retryCount + 1);
          }
          
          // 구체적인 오류 메시지
          if (error.name === 'NotSupportedError') {
            console.error('🚫 이 브라우저는 Push 알림을 지원하지 않습니다');
          } else if (error.name === 'NotAllowedError') {
            console.error('🚫 Push 알림 권한이 거부되었습니다');
          } else if (error.name === 'InvalidStateError') {
            console.error('🚫 Service Worker가 올바르게 등록되지 않았습니다');
          }
          
          return null;
        }
      }

      // 🌐 서버에 구독 정보 전송
      async sendSubscriptionToServer(subscription) {
        try {
          const response = await fetch('/api/push-subscribe', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              subscription: subscription,
              userId: AppState.userId || 'anonymous',
              userAgent: navigator.userAgent,
              timestamp: new Date().toISOString()
            })
          });

          if (response.ok) {
            console.log('✅ 구독 정보 서버 전송 완료');
            return true;
          } else {
            console.error('❌ 구독 정보 서버 전송 실패:', response.status);
            return false;
          }
        } catch (error) {
          console.error('❌ 구독 정보 전송 오류:', error);
          return false;
        }
      }

      // 🔄 기존 구독 확인
      async checkExistingSubscription() {
        if (!this.serviceWorkerRegistration) return null;

        try {
          const subscription = await this.serviceWorkerRegistration.pushManager.getSubscription();
          if (subscription) {
            console.log('✅ 기존 구독 발견:', subscription);
            this.subscription = subscription;
            return subscription;
          }
          return null;
        } catch (error) {
          console.error('❌ 기존 구독 확인 실패:', error);
          return null;
        }
      }

      // 🔔 Push 알림 초기화 (전체 프로세스)
      async initPushNotifications() {
        console.log('🚀 Push 알림 초기화 시작...');

        // 1. 브라우저 지원 확인
        if (!this.checkPushSupport()) {
          console.warn('⚠️ Push 알림 미지원, 기존 방식 사용');
          return false;
        }

        // 2. Service Worker 등록
        const registration = await this.registerServiceWorker();
        if (!registration) {
          console.error('❌ Service Worker 등록 실패');
          return false;
        }

        // 3. 알림 권한 요청
        const permission = await this.requestPermission();
        if (permission !== 'granted') {
          console.warn('⚠️ 알림 권한 거부됨');
          return false;
        }

        // 4. 기존 구독 확인
        let subscription = await this.checkExistingSubscription();
        
        // 5. 새 구독 생성 (기존 구독이 없는 경우)
        if (!subscription) {
          subscription = await this.subscribeToPush();
        } else {
          // 기존 구독을 서버에 다시 전송 (서버 재시작 등을 고려)
          await this.sendSubscriptionToServer(subscription);
        }

        if (subscription) {
          console.log('🎉 Push 알림 초기화 완료!');
          return true;
        } else {
          console.error('❌ Push 구독 실패');
          return false;
        }
      }

      // 🚀 초기화
      async init() {
        // 설정 로드
        this.loadSettings();
        
        // Page Visibility API 연동
        document.addEventListener('visibilitychange', () => {
          this.handleVisibilityChange();
        });
        
        // 🔔 페이지 종료 시 모든 알림 정리
        window.addEventListener('beforeunload', () => {
          this.notificationQueue.clearAll();
        });
        
        // 🔔 페이지 숨김 시 정리 작업
        window.addEventListener('pagehide', () => {
          this.notificationQueue.clearAll();
        });
        
        // 초기 상태 설정
        this.handleVisibilityChange();
        
        // Push 알림 초기화 (비동기)
        this.initPushNotifications().catch(error => {
          console.error('❌ Push 알림 초기화 실패:', error);
        });
        
        console.log('🔔 NotificationManager 초기화 완료');
      }
    }

    // 전역 NotificationManager 인스턴스
    const notificationManager = new NotificationManager();

    /* ===== 지능형 Keep-Alive 클라이언트 시스템 ===== */
    
    // 활성 탭 감지 시스템
    const TabActivityMonitor = {
      isActive: true,
      lastActiveTime: Date.now(),
      
      init() {
        // Page Visibility API 활용
        document.addEventListener('visibilitychange', () => {
          this.isActive = !document.hidden;
          if (this.isActive) {
            this.lastActiveTime = Date.now();
            console.log('🎯 탭 활성화 → Heartbeat 재개');
          } else {
            console.log('😴 탭 비활성화 → Heartbeat 일시중지');
          }
        });
        
        // Focus/Blur 이벤트
        window.addEventListener('focus', () => {
          this.isActive = true;
          this.lastActiveTime = Date.now();
        });
        
        window.addEventListener('blur', () => {
          this.isActive = false;
        });
        
        // 사용자 활동 감지 (마우스, 키보드)
        ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'].forEach(event => {
          document.addEventListener(event, () => {
            if (this.isActive) {
              this.lastActiveTime = Date.now();
            }
          }, { passive: true });
        });
      },
      
      shouldSendHeartbeat() {
        // 탭이 활성화되어 있고, 최근 5분 내 활동이 있었다면
        const fiveMinutes = 5 * 60 * 1000;
        return this.isActive && (Date.now() - this.lastActiveTime < fiveMinutes);
      }
    };
    
    // Socket.IO 기반 지능형 Heartbeat 시스템
    const SmartHeartbeat = {
      intervalId: null,
      stats: {
        sent: 0,
        received: 0,
        lastPing: null,
        averageLatency: 0
      },
      
      start() {
        // 3분마다 heartbeat (Socket.IO 기본 ping보다 느리게)
        // MemoryManager가 아직 정의되지 않았으므로 일반 setInterval 사용
        this.intervalId = setInterval(() => {
          if (TabActivityMonitor.shouldSendHeartbeat() && socket.connected) {
            this.sendHeartbeat();
          }
        }, 3 * 60 * 1000); // 3분 간격
        
        console.log('❤️ 지능형 Heartbeat 시스템 시작됨 (3분 간격)');
      },
      
      stop() {
        if (this.intervalId) {
          clearInterval(this.intervalId);
          this.intervalId = null;
          console.log('💔 Heartbeat 시스템 중지됨');
        }
      },
      
      sendHeartbeat() {
        const startTime = Date.now();
        this.stats.lastPing = startTime;
        this.stats.sent++;
        
        // Socket.IO의 volatile emit 사용 (연결 끊어져도 버퍼링하지 않음)
        socket.volatile.emit('client-heartbeat', { timestamp: startTime }, (response) => {
          const latency = Date.now() - startTime;
          this.stats.received++;
          
          // 이동 평균으로 지연시간 계산
          if (this.stats.averageLatency === 0) {
            this.stats.averageLatency = latency;
          } else {
            this.stats.averageLatency = Math.round((this.stats.averageLatency * 0.8) + (latency * 0.2));
          }
          
          console.log(`💓 Heartbeat: ${latency}ms (avg: ${this.stats.averageLatency}ms)`);
        });
      }
    };
    
    // Socket.IO 연결 상태 모니터링
    socket.on('connect', () => {
      console.log('✅ Socket.IO 연결됨 - Keep-Alive 자동 활성화');
      SmartHeartbeat.start();
      
      // 🔔 앱 시작 시 알림 시스템 자동 초기화
      setTimeout(async () => {
        console.log('🔔 알림 시스템 초기화 시작...');
        
        // 기본 설정 로드
        notificationManager.loadSettings();
        
        // 기본 사운드 초기화
        await notificationManager.initializeAudio();
        
        // 브라우저 알림 권한 자동 요청 (사용자 인터랙션 시)
        if (Notification.permission === 'default') {
          console.log('🔔 알림 권한이 아직 요청되지 않음 - 사용자 상호작용 시 요청');
        } else if (Notification.permission === 'granted') {
          // 권한이 이미 허용된 경우 Push 알림 초기화
          console.log('🔔 알림 권한 허용됨 - Push 시스템 초기화');
          notificationManager.initializePush();
        } else {
          console.log('🔔 알림 권한 거부됨 - 기본 기능만 사용');
        }
        
        console.log('✅ 알림 시스템 초기화 완료');
      }, 1000);
    });
    
    socket.on('disconnect', (reason) => {
      console.log('❌ Socket.IO 연결 해제:', reason);
      SmartHeartbeat.stop();
    });
    
    socket.on('reconnect', (attemptNumber) => {
      console.log(`🔄 Socket.IO 재연결 성공 (시도: ${attemptNumber})`);
      SmartHeartbeat.start();
    });
    
    // ping/pong 이벤트 모니터링 (디버깅용)
    socket.io.on('ping', () => {
      console.log('🏓 Socket.IO ping 수신');
    });
    
    socket.io.on('pong', (latency) => {
      console.log(`🏓 Socket.IO pong 수신 (${latency}ms)`);
    });
    
    // 초기화
    TabActivityMonitor.init();
    
    /* ===== 도우미 함수들 ===== */
    // DOM 유틸리티 - 현대적인 에러 처리와 null 체크 적용
    const DOM = {
      el: (selector) => {
        try {
          const element = document.querySelector(selector);
          if (!element && selector !== '#requestNotificationBtn' && selector !== '#permissionRequestArea' && selector !== '#permissionDeniedArea') {
            // 알림 관련 요소들은 조용히 처리 (선택적 기능이므로)
            console.debug(`[DOM] 요소를 찾을 수 없습니다: ${selector}`);
          }
          return element;
        } catch (error) {
          console.error(`[DOM] 선택자 오류: ${selector}`, error);
          return null;
        }
      },
      elAll: (selector) => {
        try {
          return document.querySelectorAll(selector);
        } catch (error) {
          console.error(`[DOM] 선택자 오류: ${selector}`, error);
          return [];
        }
      },
      create: (tag, className) => {
        try {
          const el = document.createElement(tag);
          if (className) el.className = className;
          return el;
        } catch (error) {
          console.error(`[DOM] 요소 생성 오류: ${tag}`, error);
          return null;
        }
      },
      // 안전한 이벤트 바인딩 유틸리티
      safeAssign: (selector, property, value) => {
        const element = DOM.el(selector);
        if (element && property in element) {
          element[property] = value;
          return true;
        } else {
          console.warn(`[DOM] 안전 할당 실패: ${selector}.${property}`);
          return false;
        }
      }
    };
    
    // 레거시 지원을 위한 el 함수 복원 - DOM.el과 동일한 안전성 제공
    const el = (selector) => DOM.el(selector);
    
    // 캐시 도우미
    const messagesEl = DOM.el('#messages');
    
    // ID 및 시그니처 생성
    const Utils = {
      generateMessageId: () => `mid-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
      
      createReactionSignature: (reactions) => {
        if (!reactions || typeof reactions !== 'object') return '{}';
        
        const normalized = {};
        Object.keys(reactions)
          .sort((a, b) => a.localeCompare(b))
          .forEach(key => {
            normalized[key] = [...(reactions[key] || [])].sort();
          });
        return JSON.stringify(normalized);
      },
      
      setButtonLoading: (button, loading) => {
        if (!button) return;
        
        const spinner = button.querySelector('.spinner');
        const label = button.querySelector('.label-txt');
        
        if (loading) {
          if (spinner) spinner.style.display = 'inline-block';
          if (label) label.style.display = 'none';
          button.disabled = true;
        } else {
          if (spinner) spinner.style.display = 'none';
          if (label) label.style.display = '';
          button.disabled = false;
        }
      },
      
      sanitizeInput: (input, maxLength = CONFIG.MAX_MESSAGE_LENGTH) => {
        if (typeof input !== 'string') return '';
        return input.trim().slice(0, maxLength);
      }
    };

    /* ===== 날짜/시간 포매터 ===== */
    const DateUtils = {
      // 날짜 키 생성 (YYYY-M-D)
      getDateKey: (timestamp) => {
        const date = new Date(timestamp);
        return [date.getFullYear(), date.getMonth() + 1, date.getDate()].join('-');
      },
      
      // 날짜 라벨 포매팅 (2024.01.01 (월))
      formatDateLabel: (timestamp) => {
        const date = new Date(timestamp);
        const weekdays = ['일', '월', '화', '수', '목', '금', '토'];
        const weekday = weekdays[date.getDay()];
        
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        
        return `${year}.${month}.${day} (${weekday})`;
      },
      
      // 시간 라벨 포매팅 (오전 10:30)
      formatTimeLabel: (timestamp) => {
        return new Intl.DateTimeFormat('ko-KR', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        }).format(new Date(timestamp));
      }
    };

    /* ===== Win98 Toggle + Click Sound ===== */
    const applyTheme98 = (on)=>{
      document.body.classList.toggle('win98', !!on);
      localStorage.setItem('theme98',''+(on?1:0));
    };
    const restoreTheme98 = ()=> applyTheme98(localStorage.getItem('theme98')==='1');
    // 오디오 시스템 - 개선된 에러 처리와 폴백
    let audioCtx = null;
    let audioInitialized = false;
    
    function beep(){
      // 테마가 활성화되지 않았으면 조용히 반환
      if (!document.body.classList.contains('win98')) return;
      
      try {
        // AudioContext 초기화 (지연 초기화)
        if (!audioCtx) {
          const AudioContextClass = window.AudioContext || window.webkitAudioContext;
          if (!AudioContextClass) {
            console.warn('[사운드] Web Audio API를 지원하지 않는 브라우저입니다');
            return;
          }
          
          audioCtx = new AudioContextClass();
          console.log('[사운드] AudioContext 초기화 완료');
        }

        // AudioContext 재개 (브라우저 정책으로 인한 suspend 상태 해결)
        if (audioCtx.state === 'suspended') {
          audioCtx.resume().catch(err => {
            console.warn('[사운드] AudioContext 재개 실패:', err);
          });
        }

        // 사운드 생성
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        
        oscillator.type = 'square';
        oscillator.frequency.value = 800;
        
        gainNode.gain.setValueAtTime(0.06, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.08);
        
        oscillator.connect(gainNode).connect(audioCtx.destination);
        oscillator.start();
        oscillator.stop(audioCtx.currentTime + 0.09);
        
        audioInitialized = true;

      } catch (error) {
        // 조용한 실패 - 사운드는 필수가 아니므로 로그만 남김
        if (!audioInitialized) {
          console.warn('[사운드] 오디오 시스템 초기화 실패:', error.message);
          audioInitialized = true; // 재시도 방지
        }
      }
    }
    function attachBeepTo(selector){
      document.addEventListener('click', (e)=>{
        if (e.target.closest(selector)) beep();
      });
    }

    /* ===== Responsive helpers ===== */
    const isCompact = () => window.innerWidth <= 480;

    /* ===== UI Base ===== */
    function enableUI(enable){
      ['nickname','status','avatar','clearAvatar','saveBtn','text','sendBtn','photoBtn'].forEach(id=>{
        const n = DOM.el('#'+id); if (n) n.disabled = !enable;
      });
      DOM.el('.wrap').setAttribute('aria-disabled', enable ? 'false' : 'true');
      // 헤더 로그아웃 버튼 토글
      DOM.el('#logoutBtn').style.display = enable ? 'inline-flex' : 'none';
      // 로그인 안내 문구 토글
      DOM.el('#loginNotice').style.display = enable ? 'none' : 'block';
    }
    function setAvatar(url){ const img=DOM.el('#avatarImg'); if(url&&url.trim()){ img.src=url; img.style.visibility='visible'; } else { img.removeAttribute('src'); img.style.visibility='hidden'; } }

    function labelFor(roomName){
      if (isCompact() && roomName.indexOf('방문예정')===0) return '방문예정';
      return roomName;
    }
    function setActiveTabUI() {
      document.querySelectorAll('.tab').forEach(t=>{
        t.classList.toggle('active', t.textContent.replace(/\s/g,'') === UI.labelFor(AppState.currentRoom).replace(/\s/g,''));
      });
    }
    // 🔗 답글 관리 매니저
    const ReplyManager = {
      // 답글 시작
      startReply: (targetMid, targetNick) => {
        AppState.reply.active = true;
        AppState.reply.targetMid = targetMid;
        AppState.reply.targetNick = targetNick;
        
        // UI 업데이트
        const replyIndicator = DOM.el('#replyIndicator');
        const replyTarget = DOM.el('#replyTarget');
        
        replyTarget.textContent = targetNick;
        replyIndicator.style.display = 'block';
        
        // 입력창에 포커스
        DOM.el('#text').focus();
        
        console.log(`[REPLY] 답글 시작: ${targetMid} (${targetNick})`);
      },
      
      // 답글 취소
      cancelReply: () => {
        AppState.reply.active = false;
        AppState.reply.targetMid = null;
        AppState.reply.targetNick = null;
        
        // UI 업데이트
        const replyIndicator = DOM.el('#replyIndicator');
        replyIndicator.style.display = 'none';
        
        console.log('[REPLY] 답글 모드 종료');
      }
    };

    // ===== 방 전환 관리 =====
    const RoomManager = {
      switchRoom: (nextRoom) => {
        if (nextRoom === AppState.currentRoom) return;
        
        // 방 전환 중이면 무시 (연속 클릭 방지)
        if (AppState.flags.switching) return;
        
        // 입력 검증
        if (!CONFIG.ROOMS.includes(nextRoom)) {
          console.warn('잘못된 방 이름:', nextRoom);
          return;
        }
        
        try {
          console.log(`[ROOM] 방 전환 시작: ${AppState.currentRoom} → ${nextRoom}`);
          
          // 🚀 즉시 UI 피드백 - 탭 상태를 먼저 업데이트
          const prevRoom = AppState.currentRoom;
          AppState.currentRoom = nextRoom;
          UI.drawTabs();
          UI.setActiveTabUI();
          
          // 방 전환 시작
          AppState.flags.switching = true;
          
          // 1. 이전 방에서 완전 이탈
          socket.emit('leaveRoom', prevRoom);
          
          // 2. UI 초기화 - 채팅 영역 클리어 및 로딩 표시
          messagesEl.innerHTML = '<div class="loading-skeleton">메시지를 불러오는 중...</div>';
          
          // 3. 캐시 초기화 (해당 방의 렌더링된 메시지 ID 초기화)
          AppState.cache.renderedMids[AppState.currentRoom].clear();
          AppState.cache.lastTs[AppState.currentRoom] = AppState.cache.lastTs[AppState.currentRoom] || 0;
          AppState.cache.lastDayRendered[AppState.currentRoom] = '';
          
          // 4. 새 방에 입장
          socket.emit('joinRoom', AppState.currentRoom);
          
          // 6. 🚀 프리로드 체크 및 데이터 로드
          setTimeout(() => {
            // 프리로드된 메시지가 있으면 즉시 사용
            const usedPreload = PreloadManager.usePreloadedIfAvailable(AppState.currentRoom);
            
            if (usedPreload) {
              // 프리로드된 메시지로 즉시 렌더링 후 최신 메시지만 추가 로드
              DataManager.fetchAndRender(true, false).finally(() => {
                AppState.flags.switching = false;
                MessageManager.onRoomSwitch();
                PreloadManager.updateRoomStats(AppState.currentRoom);
                console.log(`[ROOM] 방 전환 완료 (프리로드 사용): ${prevRoom} → ${nextRoom}`);
              });
            } else {
              // 일반적인 전체 로드
              DataManager.fetchAndRender(true, true).finally(() => {
                AppState.flags.switching = false;
                MessageManager.onRoomSwitch();
                PreloadManager.updateRoomStats(AppState.currentRoom);
                console.log(`[ROOM] 방 전환 완료: ${prevRoom} → ${nextRoom}`);
              });
            }
          }, 100); // Socket 이벤트 처리 시간 확보
          
          // 모바일 UI 정리
          document.body.classList.remove('profile-open');
        } catch (error) {
          console.error('방 전환 오류:', error);
          // 에러 시 이전 방으로 되돌리기 또는 사용자에게 알림
        }
      }
    };

    // 🚀 스크롤 관리 유틸리티
    const ScrollManager = {
      // 스크롤 컨테이너 가져오기 (개선된 구조)
      getScrollContainer() {
        return document.querySelector('.messages') || document.getElementById('messages');
      },
      
      // 현재 스크롤이 하단에 있는지 확인
      isAtBottom(threshold = 80) {
        const container = this.getScrollContainer();
        if (!container) return true;
        
        return Math.abs(container.scrollHeight - container.scrollTop - container.clientHeight) < threshold;
      },
      
      // 부드럽게 하단으로 스크롤
      scrollToBottom(smooth = true) {
        const container = this.getScrollContainer();
        if (!container) return;
        
        if (smooth && 'scrollTo' in container) {
          container.scrollTo({
            top: container.scrollHeight,
            behavior: 'smooth'
          });
        } else {
          container.scrollTop = container.scrollHeight;
        }
      },
      
      // 스크롤 위치 저장
      saveScrollPosition() {
        const container = this.getScrollContainer();
        if (!container) return null;
        
        return {
          scrollTop: container.scrollTop,
          scrollHeight: container.scrollHeight,
          clientHeight: container.clientHeight
        };
      },
      
      // 스크롤 위치 복원 (새 메시지 로드 후)
      restoreScrollPosition(savedPosition) {
        const container = this.getScrollContainer();
        if (!container || !savedPosition) return;
        
        const newScrollHeight = container.scrollHeight;
        const heightDifference = newScrollHeight - savedPosition.scrollHeight;
        
        container.scrollTop = savedPosition.scrollTop + heightDifference;
      },
      
      // 메시지 전송 후 자동 스크롤 (조건부)
      autoScrollAfterMessage() {
        if (this.isAtBottom()) {
          this.scrollToBottom(false); // 즉시 스크롤
        }
      },
      
      // 스크롤 상태 디버그 정보
      getScrollInfo() {
        const container = this.getScrollContainer();
        if (!container) return null;
        
        const maxScroll = container.scrollHeight - container.clientHeight;
        return {
          scrollTop: container.scrollTop,
          scrollHeight: container.scrollHeight,
          clientHeight: container.clientHeight,
          isAtBottom: this.isAtBottom(),
          scrollPercentage: maxScroll > 0 ? Math.round((container.scrollTop / maxScroll) * 100) : 100
        };
      },
      
      // 특정 메시지로 스크롤하고 하이라이트
      scrollToMessage(messageId, highlight = true) {
        console.log(`🎯 메시지로 스크롤 시도: ${messageId}`);
        
        if (!messageId) {
          console.warn('⚠️ messageId가 제공되지 않았습니다');
          return false;
        }
        
        const targetElement = document.querySelector(`[data-mid="${messageId}"]`);
        if (!targetElement) {
          console.warn(`⚠️ 메시지를 찾을 수 없습니다: ${messageId}`);
          // 다른 선택자들도 시도해보기
          const altTargets = [
            document.getElementById(messageId),
            document.querySelector(`#msg-${messageId}`),
            document.querySelector(`[id*="${messageId}"]`)
          ].filter(Boolean);
          
          if (altTargets.length > 0) {
            console.log(`✅ 대체 선택자로 요소 발견: ${altTargets[0].tagName}`);
            return this.scrollToElement(altTargets[0], highlight);
          }
          
          return false;
        }
        
        return this.scrollToElement(targetElement, highlight);
      },
      
      scrollToElement(targetElement, highlight = true) {
        console.log('📍 요소로 스크롤 실행');
        
        const container = this.getScrollContainer();
        if (!container) {
          console.error('❌ 스크롤 컨테이너를 찾을 수 없습니다');
          return false;
        }
        
        try {
          // 메시지 요소의 위치 계산
          const containerRect = container.getBoundingClientRect();
          const targetRect = targetElement.getBoundingClientRect();
          
          // 스크롤할 위치 계산 (메시지를 중앙에 배치)
          const scrollTop = container.scrollTop + targetRect.top - containerRect.top - (containerRect.height / 2) + (targetRect.height / 2);
          
          console.log(`📏 스크롤 계산: scrollTop=${scrollTop}, container.scrollTop=${container.scrollTop}`);
          
          // 부드럽게 스크롤
          if ('scrollTo' in container) {
            container.scrollTo({
              top: Math.max(0, scrollTop),
              behavior: 'smooth'
            });
          } else {
            container.scrollTop = Math.max(0, scrollTop);
          }
          
          // 하이라이트 효과
          if (highlight) {
            console.log('✨ 메시지 하이라이트 효과 적용');
            targetElement.style.transition = 'background-color 0.3s ease';
            targetElement.style.backgroundColor = '#fff3cd';
            setTimeout(() => {
              targetElement.style.backgroundColor = '';
              setTimeout(() => {
                targetElement.style.transition = '';
              }, 300);
            }, 1000);
          }
          
          console.log('✅ 메시지로 스크롤 완료');
          return true;
        } catch (error) {
          console.error('❌ 스크롤 중 오류 발생:', error);
          return false;
        }
      }
    };

    // 🚀 백그라운드 프리로딩 매니저
    const PreloadManager = {
      // 방 방문 통계 업데이트
      updateRoomStats: (roomName) => {
        AppState.roomStats.visitCount[roomName] = (AppState.roomStats.visitCount[roomName] || 0) + 1;
        AppState.roomStats.lastVisit[roomName] = Date.now();
        
        // 자주 방문하는 방들의 메시지 백그라운드 프리로드
        setTimeout(() => PreloadManager.preloadFrequentRooms(), 2000);
      },
      
      // 자주 방문하는 방들 백그라운드 프리로드
      preloadFrequentRooms: async () => {
        if (!AppState.userId) return;
        
        const frequentRooms = CONFIG.ROOMS.filter(room => {
          const visitCount = AppState.roomStats.visitCount[room] || 0;
          return visitCount >= AppState.roomStats.preloadThreshold && room !== AppState.currentRoom;
        });
        
        for (const room of frequentRooms) {
          // 이미 프리로드됐거나 최근에 방문한 방은 스킵
          const lastPreload = AppState.cache.preloadedMessages[room]?.timestamp || 0;
          if (Date.now() - lastPreload < 5 * 60 * 1000) continue; // 5분 쿨다운
          
          try {
            console.log(`[PRELOAD] 백그라운드 프리로딩: ${room}`);
            const response = await apiCall('GET', `/api/messages/${room}?limit=20`);
            const messages = response?.messages || response || [];
            
            AppState.cache.preloadedMessages[room] = {
              messages: messages,
              timestamp: Date.now()
            };
          } catch (error) {
            console.warn(`방 ${room} 프리로드 실패:`, error);
          }
        }
      },
      
      // 프리로드된 메시지가 있으면 즉시 렌더링
      usePreloadedIfAvailable: (roomName) => {
        const preloaded = AppState.cache.preloadedMessages[roomName];
        if (preloaded && Date.now() - preloaded.timestamp < 10 * 60 * 1000) { // 10분 유효
          console.log(`[PRELOAD] 프리로드된 메시지 사용: ${roomName}`);
          preloaded.messages.forEach(addOrUpdateMsg);
          return true;
        }
        return false;
      }
    };

    // 🚀 이미지 지연 로딩 매니저
    const LazyImageManager = {
      observer: null,
      
      init: () => {
        if ('IntersectionObserver' in window) {
          LazyImageManager.observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                const img = entry.target;
                LazyImageManager.loadImage(img);
                LazyImageManager.observer.unobserve(img);
              }
            });
          }, {
            rootMargin: '50px', // 이미지가 화면에 보이기 50px 전부터 로딩 시작
            threshold: 0.01
          });
        }
      },
      
      loadImage: (img) => {
        const dataSrc = img.getAttribute('data-src');
        if (dataSrc) {
          img.classList.add('loading');
          
          // 새로운 이미지 객체를 만들어 미리 로딩
          const imageLoader = new Image();
          imageLoader.onload = () => {
            img.src = dataSrc;
            img.classList.remove('loading');
            img.classList.add('loaded');
            img.removeAttribute('data-src');
          };
          imageLoader.onerror = () => {
            img.classList.remove('loading');
            img.alt = '이미지 로딩 실패';
            img.style.filter = 'grayscale(1)';
          };
          imageLoader.src = dataSrc;
        }
      },
      
      observeImages: () => {
        if (LazyImageManager.observer) {
          document.querySelectorAll('.lazy-image:not(.loaded):not(.loading)').forEach(img => {
            LazyImageManager.observer.observe(img);
          });
        }
      }
    };

    const UI = {
      drawTabs: () => {
        const tabs = DOM.el('#tabs'); tabs.innerHTML='';
        CONFIG.ROOMS.forEach(r=>{
          const b = DOM.create('div', 'tab');
          b.textContent = UI.labelFor(r);
          b.title = r; b.setAttribute('aria-label', r);
          b.onclick = () => RoomManager.switchRoom(r);
          tabs.appendChild(b);
        });
        UI.setActiveTabUI();
      },
      
      labelFor: (roomName) => {
        if (UI.isCompact() && roomName.indexOf('방문예정')===0) return '방문예정';
        return roomName;
      },
      
      setActiveTabUI: () => {
        document.querySelectorAll('.tab').forEach(t=>{
          t.classList.toggle('active', t.textContent.replace(/\s/g,'') === UI.labelFor(AppState.currentRoom).replace(/\s/g,''));
        });
      },
      
      isCompact: () => window.innerWidth <= 480
    };
    
    // Legacy support for drawTabs - now uses UI.drawTabs()
    function drawTabs(){
      return UI.drawTabs();
    }
    function setActiveTabUI(){
      return UI.setActiveTabUI();
    }
    function labelFor(roomName){
      return UI.labelFor(roomName);
    }
    function initialLetter(name){ const t=String(name||'').trim(); return t? t[0].toUpperCase() : 'U'; }

    /* ===== 접속자 관리 ===== */
    const ConnectedUsersUI = {
      // 접속자 목록 렌더링
      render: (users) => {
        const container = DOM.el('#usersGrid');
        const header = DOM.el('#connectedHeader');
        const section = DOM.el('#connectedUsers');
        
        if (!users || users.length === 0) {
          section.style.display = 'none';
          return;
        }
        
        // 헤더 업데이트
        header.textContent = `현재 접속자 (${users.length})`;
        
        // 아바타 그리드 렌더링
        container.innerHTML = users.map(user => {
          const safeInitial = initialLetter(user.nickname || '');
          if (user.avatar && user.avatar.trim()) {
            return `<div class="user-avatar" data-user-id="${user.userId}" data-nickname="${(user.nickname||'')}" data-avatar="${(user.avatar||'')}" data-status="${(user.status||'')}" title="${user.nickname || 'User'}">
                      <img src="${user.avatar}" onerror="this.remove();this.parentElement.textContent='${safeInitial}';" />
                    </div>`;
          } else {
            return `<div class="user-avatar" data-user-id="${user.userId}" data-nickname="${(user.nickname||'')}" data-avatar="" data-status="${(user.status||'')}" title="${user.nickname || 'User'}">
                      <span>${safeInitial}</span>
                    </div>`;
          }
        }).join('');
        
        // 클릭 이벤트 바인딩
        container.querySelectorAll('.user-avatar').forEach(avatar => {
          avatar.addEventListener('click', () => {
            const userId = avatar.getAttribute('data-user-id');
            const nickname = avatar.getAttribute('data-nickname') || 'User';
            const avatarUrl = avatar.getAttribute('data-avatar') || '';
            const status = avatar.getAttribute('data-status') || '';
            
            openProfile(userId, nickname, avatarUrl);
          });
        });
        
        // 섹션 표시
        section.style.display = 'block';
      },
      
      // 사용자 추가
      addUser: (user) => {
        // workStatus 기본값 설정
        if (!user.workStatus) {
          user.workStatus = 'offline';
        }
        const existingIndex = AppState.connectedUsers.findIndex(u => u.userId === user.userId);
        if (existingIndex >= 0) {
          // 기존 사용자 업데이트
          AppState.connectedUsers[existingIndex] = user;
        } else {
          // 새 사용자 추가
          AppState.connectedUsers.push(user);
        }
        ConnectedUsersUI.render(AppState.connectedUsers);
      },
      
      // 사용자 제거
      removeUser: (userId) => {
        AppState.connectedUsers = AppState.connectedUsers.filter(u => u.userId !== userId);
        ConnectedUsersUI.render(AppState.connectedUsers);
      },
      
      // 사용자 정보 업데이트
      updateUser: (user) => {
        const existingIndex = AppState.connectedUsers.findIndex(u => u.userId === user.userId);
        if (existingIndex >= 0) {
          AppState.connectedUsers[existingIndex] = { ...AppState.connectedUsers[existingIndex], ...user };
          ConnectedUsersUI.render(AppState.connectedUsers);
        }
      },
      
      // 전체 목록 설정
      setUsers: (users) => {
        AppState.connectedUsers = users || [];
        // 각 사용자의 workStatus 정보도 보존
        AppState.connectedUsers.forEach(user => {
          if (!user.workStatus) {
            user.workStatus = 'offline';  // 기본값 설정
          }
        });
        ConnectedUsersUI.render(AppState.connectedUsers);
      }
    };

    /* ===== API 호출 함수들 ===== */
    async function apiCall(method, url, body = null) {
      try {
        const options = {
          method,
          headers: {
            'Content-Type': 'application/json',
          },
        };
        
        if (body && method !== 'GET') {
          options.body = JSON.stringify(body);
        }
        
        const response = await fetch(url, options);
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'API 요청 실패');
        }
        
        return await response.json();
      } catch (error) {
        throw error;
      }
    }

    /* ===== Reactions ===== */
    function reactsToCounts(reactions){
      const counts = [];
      for (const k of Object.keys(reactions||{})){
        const arr = reactions[k]||[];
        if (arr.length) counts.push({emoji:k, count:arr.length, mine:(arr.indexOf(AppState.userId)>=0)});
      }
      counts.sort((a,b)=> b.count-a.count || CONFIG.EMOJIS.indexOf(a.emoji)-CONFIG.EMOJIS.indexOf(b.emoji));
      return counts;
    }
    function renderReactsHtml(m){
      const sig = Utils.createReactionSignature(m.reactions||{});
      const chips = reactsToCounts(m.reactions||{}).map(c=>`<span class="chip ${c.mine?'mine':''}" data-mid="${m.mid}" data-emoji="${c.emoji}">${c.emoji} ${c.count}</span>`).join('');
      const picker = CONFIG.EMOJIS.map(e=>`<button class="pick" data-mid="${m.mid}" data-emoji="${e}" title="반응 추가">${e}</button>`).join('');
      return `<div class="reacts" id="reacts-${m.mid}" data-sig='${sig}'>
        <div class="chips">${chips}</div>
        <button class="add-react" data-mid="${m.mid}" title="반응 추가">＋</button>
        <div class="picker hidden" id="picker-${m.mid}">${picker}</div>
      </div>`;
    }
    function bindReactionHandlers(mid){
      const root = document.getElementById('reacts-'+mid); if(!root) return;
      root.querySelectorAll('.chip').forEach(ch=>{
        ch.onclick = (e)=>{ e.stopPropagation(); reactToggle(mid, ch.getAttribute('data-emoji')); };
      });
      const addBtn = root.querySelector('.add-react');
      if (addBtn){
        addBtn.onclick = (e)=>{ e.stopPropagation(); const p=document.getElementById('picker-'+mid); if(p) p.classList.toggle('hidden'); };
      }
      root.querySelectorAll('.pick').forEach(b=>{
        b.onclick = (e)=>{ e.stopPropagation(); reactToggle(mid, b.getAttribute('data-emoji')); const p=document.getElementById('picker-'+mid); if(p) p.classList.add('hidden'); };
      });
    }
    function updateReactsView(m){
      const node = document.getElementById('reacts-'+m.mid);
      if (!node) return;
      const pickerOpen = !(node.querySelector('.picker')?.classList.contains('hidden'));
      const oldSig = node.dataset.sig || '';
      const newSig = Utils.createReactionSignature(m.reactions||{});
      if (pickerOpen || oldSig === newSig) return;
      node.outerHTML = renderReactsHtml(m);
      bindReactionHandlers(m.mid);
    }
    
    // 🔗 답글 버튼 이벤트 핸들러
    function bindReplyHandlers(mid){
      const replyBtn = document.querySelector(`[data-mid="${mid}"].reply-btn`);
      if (replyBtn) {
        replyBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const targetMid = replyBtn.getAttribute('data-mid');
          const targetNick = replyBtn.getAttribute('data-nick');
          ReplyManager.startReply(targetMid, targetNick);
        });
      }
    }
    
    // 👑 관리자 삭제 버튼 이벤트 핸들러
    function bindAdminDeleteHandlers(mid){
      if (!AppState.isAdmin) return;
      
      const deleteBtn = document.querySelector(`[data-mid="${mid}"].admin-delete-btn`);
      if (deleteBtn) {
        deleteBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          const targetMid = deleteBtn.getAttribute('data-mid');
          
          // 삭제 확인 다이얼로그
          const messageRow = document.querySelector(`[data-message-id="${targetMid}"]`);
          const senderName = messageRow?.getAttribute('data-sender-name') || '알 수 없는 사용자';
          
          if (confirm(`${senderName}의 메시지를 삭제하시겠습니까?\n\n⚠️ 이 작업은 되돌릴 수 없습니다.`)) {
            await deleteMessage(targetMid);
          }
        });
      }
    }
    
    // 👑 관리자 메시지 삭제 함수
    async function deleteMessage(mid) {
      if (!AppState.isAdmin) {
        console.error('[관리자] 권한이 없습니다');
        alert('관리자 권한이 필요합니다.');
        return;
      }
      
      try {
        console.log(`[관리자] 메시지 삭제 요청: ${mid}`);
        
        // 서버에 삭제 요청
        const result = await apiCall('DELETE', `/api/messages/${mid}`, {
          adminUserId: AppState.userId,
          reason: 'admin_delete'
        });
        
        if (result.success) {
          console.log(`[관리자] 메시지 삭제 성공: ${mid}`);
          
          // UI에서 메시지 제거
          const messageRow = document.querySelector(`[data-message-id="${mid}"]`);
          if (messageRow) {
            messageRow.style.opacity = '0.3';
            messageRow.style.transform = 'translateX(-20px)';
            
            setTimeout(() => {
              messageRow.remove();
              
              // 캐시에서도 제거
              AppState.cache.renderedMids[AppState.currentRoom].delete(mid);
              
              console.log(`[관리자] UI에서 메시지 제거 완료: ${mid}`);
            }, 300);
          }
          
          // 다른 사용자들에게 삭제 알림 (Socket.IO 이벤트)
          if (socket && socket.emit) {
            socket.emit('messageDeleted', { mid, adminId: AppState.userId });
          }
          
        } else {
          throw new Error(result.error || '메시지 삭제 실패');
        }
        
      } catch (error) {
        console.error('[관리자] 메시지 삭제 오류:', error);
        alert(`메시지 삭제 실패: ${error.message}`);
      }
    }
    
    async function reactToggle(mid, emoji){
      try {
        const result = await apiCall('POST', '/api/reactions', { mid, userId: AppState.userId, emoji });
        updateReactsView(result);
        beep();
      } catch (error) {
        alert('반응 실패: ' + error.message);
      }
    }

    /* ===== Profile Modal ===== */
    function showProfileModal(nickname, avatar, status, userId = null){
      DOM.el('#pname').textContent = nickname || 'User';
      DOM.el('#pstatus').textContent = status ? status : '상태메시지 없음';
      const img = DOM.el('#pimg');
      if (avatar && avatar.trim()){
        img.style.display='block';
        img.onerror = ()=>{ img.style.display='none'; img.removeAttribute('src'); };
        img.src = avatar;
      } else {
        img.removeAttribute('src');
        img.style.display='none';
      }
      
      // 해당 사용자의 업무 상태 표시 업데이트
      updateModalWorkStatus(userId);
      
      // Prevent body scroll on mobile
      document.body.style.overflow = 'hidden';
      
      DOM.el('#pmodal').classList.add('show');
      DOM.el('#pmodal').setAttribute('aria-hidden','false');
    }
    function hideProfileModal(){
      DOM.el('#pmodal').classList.remove('show');
      DOM.el('#pmodal').setAttribute('aria-hidden','true');
      // Restore body scroll
      document.body.style.overflow = '';
    }
    function bindProfileModalBasics(){
      DOM.el('#pback').addEventListener('click', hideProfileModal);
      DOM.el('#pclose').addEventListener('click', hideProfileModal);
      window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideProfileModal(); });
    }
    async function openProfile(uid, fallbackNick, fallbackAvatar){
      showProfileModal(fallbackNick, fallbackAvatar, '불러오는 중…', uid);
      try {
        const profile = await apiCall('GET', `/api/profile/${uid}`);
        showProfileModal(profile.nickname || fallbackNick, profile.avatar || fallbackAvatar, profile.status || '', uid);
      } catch (error) {
        showProfileModal(fallbackNick, fallbackAvatar, '', uid);
      }
    }

    /* ===== 메시지 정보 조회 함수 ===== */
    async function fetchMessageInfo(messageId) {
      try {
        console.log(`🔍 서버에서 메시지 조회 시작: ${messageId}`);
        const response = await apiCall('GET', `/api/messages/single/${messageId}`);
        console.log(`✅ 서버에서 메시지 조회 성공:`, response);
        return response;
      } catch (error) {
        console.error(`❌ 서버에서 메시지 조회 실패 (${messageId}):`, error);
        throw error;
      }
    }

    /* ===== Messages ===== */
    function addOrUpdateMsg(m){
      if (document.getElementById('reacts-'+(m.mid||''))){ updateReactsView(m); return; }
      if (m.mid && AppState.cache.renderedMids[AppState.currentRoom].has(m.mid)) return;
      if (m.mid) AppState.cache.renderedMids[AppState.currentRoom].set(m.mid, m);

      const dayKey = DateUtils.getDateKey(m.ts);
      if (AppState.cache.lastDayRendered[AppState.currentRoom] !== dayKey){
        AppState.cache.lastDayRendered[AppState.currentRoom] = dayKey;
        const sep = document.createElement('div');
        sep.className = 'day-sep';
        sep.innerHTML = `<span class="day-chip">${DateUtils.formatDateLabel(m.ts)}</span>`;
        messagesEl.appendChild(sep);
      }

      const stayAtBottom = ScrollManager.isAtBottom();

      const row=document.createElement('div');
      const isMe = (m.userId === AppState.userId);
      row.className='msg-row '+(isMe?'me':'other');

      let avatarHtml='';
      if (!isMe){
        const safeInitial = initialLetter(m.nickname||'');
        if (m.avatar){
          avatarHtml = `<button type="button" class="avatar-sm p-open" data-uid="${m.userId}" data-nick="${(m.nickname||'')}" data-av="${(m.avatar||'')}">
                          <img src="${m.avatar}" onerror="this.remove();this.parentElement.textContent='${safeInitial}';" />
                        </button>`;
        } else {
          avatarHtml = `<button type="button" class="avatar-sm p-open" data-uid="${m.userId}" data-nick="${(m.nickname||'')}" data-av=""><span>${safeInitial}</span></button>`;
        }
      } else { avatarHtml = `<div class="avatar-sm" style="display:none;"></div>`; }

      let bubbleInner='';
      if (m.kind==='image' && m.mediaUrl){
        const key = m.mid || m.ts;
        // 🚀 이미지 지연 로딩 구현
        bubbleInner =
          `<div><img id="img-${key}" class="lazy-image" data-src="${m.mediaUrl}" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20width='200'%20height='100'%3E%3Crect%20fill='%23f3f4f6'%20width='200'%20height='100'/%3E%3Ctext%20fill='%23a3a3a3'%20x='50%25'%20y='50%25'%20text-anchor='middle'%20dy='.3em'%20font-size='12'%3E이미지 로딩 중...%3C/text%3E%3C/svg%3E" alt="${(m.fileName||'image')}" style="max-width:100%; border-radius:12px;" /></div>
           <div class="meta">${(m.nickname||'')} · ${DateUtils.formatTimeLabel(m.ts)}</div>`;
      } else {
        bubbleInner =
          `<div>${(m.text||'').replace(/\n/g,'<br/>')}</div>
           <div class="meta">${(m.nickname||'')} · ${DateUtils.formatTimeLabel(m.ts)}</div>`;
      }

      // 🔗 답글 대상 표시 HTML 생성
      let replyTargetHtml = '';
      if (m.replyTo) {
        // 답글인 경우 원본 메시지 정보 표시
        let targetName = m.replyToNickname;
        
        // 1차 fallback: 메시지 캐시에서 답글 대상 찾기
        if (!targetName || targetName === 'User') {
          const targetMessage = AppState.cache.renderedMids[AppState.currentRoom].get(m.replyTo);
          if (targetMessage && targetMessage.nickname) {
            targetName = targetMessage.nickname;
            console.log(`🔍 캐시에서 답글 대상 찾음: ${targetName}`);
          }
        }
        
        // 2차 fallback: DOM에서 답글 대상 메시지 찾기
        if (!targetName || targetName === 'User') {
          const targetElement = document.querySelector(`[data-mid="${m.replyTo}"] .meta`);
          if (targetElement) {
            const metaText = targetElement.textContent;
            const nickMatch = metaText.match(/^(.+?)\s+·/);
            if (nickMatch) {
              targetName = nickMatch[1];
              console.log(`🔍 DOM에서 답글 대상 찾음: ${targetName}`);
            }
          }
        }
        
        // 3차 fallback: 서버에서 메시지 정보 조회 (비동기)
        if (!targetName || targetName === 'User') {
          targetName = '답글 대상 조회 중...';
          // 비동기로 서버에서 메시지 정보 조회
          fetchMessageInfo(m.replyTo).then(messageInfo => {
            if (messageInfo && messageInfo.nickname) {
              // DOM 업데이트 - 카카오톡 스타일 미리보기로 변경
              const replyTargetEl = document.querySelector(`[data-mid="${m.mid}"] .reply-target`);
              if (replyTargetEl) {
                const originalContent = messageInfo.text || '메시지';
                replyTargetEl.innerHTML = `
                  <span class="original-user">${messageInfo.nickname}</span>
                  <span class="original-content">${originalContent}</span>
                `;
                replyTargetEl.setAttribute('data-reply-to', m.replyTo);
                replyTargetEl.setAttribute('onclick', `scrollToMessage('${m.replyTo}')`);
                console.log(`🔍 서버에서 답글 대상 찾음: ${messageInfo.nickname}`);
              }
            }
          }).catch(error => {
            console.warn(`⚠️ 서버에서 답글 대상 조회 실패:`, error);
            // 최후의 fallback
            const replyTargetEl = document.querySelector(`[data-mid="${m.mid}"] .reply-target`);
            if (replyTargetEl) {
              replyTargetEl.innerHTML = `
                <span class="original-user">알 수 없는 사용자</span>
                <span class="original-content">메시지</span>
              `;
            }
          });
        }
        
        // 원본 메시지 내용 가져오기
        let originalContent = m.replyToText || '';
        if (!originalContent) {
          // 캐시에서 원본 메시지 내용 찾기
          const targetMessage = AppState.cache.renderedMids[AppState.currentRoom].get(m.replyTo);
          if (targetMessage && targetMessage.text) {
            originalContent = targetMessage.text;
          } else {
            // DOM에서 원본 메시지 내용 찾기
            const targetElement = document.querySelector(`[data-mid="${m.replyTo}"] .bubble-text`);
            if (targetElement) {
              originalContent = targetElement.textContent;
            }
          }
        }
        
        // 카카오톡 스타일 미리보기 HTML 생성
        replyTargetHtml = `
          <div class="reply-target" data-reply-to="${m.replyTo}" onclick="scrollToMessage('${m.replyTo}')">
            <span class="original-user">${targetName}</span>
            <span class="original-content">${originalContent || '메시지'}</span>
          </div>
        `;
        row.classList.add('reply');
        // 스레드 연결선 표시
        if (!isMe) {
          bubbleInner = `<div class="thread-indicator"></div>${bubbleInner}`;
        }
      }
      
      // 🔗 답글 버튼 HTML
      const replyBtnHtml = `<button class="reply-btn" data-mid="${m.mid}" data-nick="${m.nickname || 'User'}" title="답글" aria-label="답글">↳</button>`;
      
      // 👑 관리자 전용 삭제 버튼 HTML
      const adminDeleteBtnHtml = AppState.isAdmin ? 
        `<button class="admin-delete-btn" data-mid="${m.mid}" title="메시지 삭제 (관리자)" aria-label="메시지 삭제">🗑️</button>` : '';
      
      const reactsHtml = renderReactsHtml(m);
      
      // 메시지 컨테이너 구조 개선
      const messageContent = `${replyTargetHtml}<div>${(m.kind === 'image' && m.mediaUrl) ? 
        `<img id="img-${m.mid || m.ts}" class="lazy-image" data-src="${m.mediaUrl}" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20width='200'%20height='100'%3E%3Crect%20fill='%23f3f4f6'%20width='200'%20height='100'/%3E%3Ctext%20fill='%23a3a3a3'%20x='50%25'%20y='50%25'%20text-anchor='middle'%20dy='.3em'%20font-size='12'%3E이미지 로딩 중...%3C/text%3E%3C/svg%3E" alt="${m.fileName || 'image'}" style="max-width:100%; border-radius:12px;" />` 
        : (m.text || '').replace(/\n/g,'<br/>')}</div>
           <div class="meta">${(m.nickname||'')} · ${DateUtils.formatTimeLabel(m.ts)}</div>${reactsHtml}`;
      
      row.innerHTML = `${avatarHtml}<div class="message-container"><div class="bubble">${messageContent}</div>${replyBtnHtml}${adminDeleteBtnHtml}</div>`;
      
      // 메시지 ID를 data attribute로 추가 (삭제 기능에 필요)
      row.setAttribute('data-message-id', m.mid);
      row.setAttribute('data-sender-name', m.nickname || 'User');
      messagesEl.appendChild(row);

      bindReactionHandlers(m.mid);
      bindReplyHandlers(m.mid);
      
      // 👑 관리자 삭제 버튼 바인딩
      if (AppState.isAdmin) {
        bindAdminDeleteHandlers(m.mid);
      }

      row.querySelectorAll('.p-open').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const uid = btn.getAttribute('data-uid');
          const nn  = btn.getAttribute('data-nick') || 'User';
          const av  = btn.getAttribute('data-av') || '';
          openProfile(uid, nn, av);
        });
      });

      const img = row.querySelector(m.kind==='image' ? `#img-${CSS.escape(m.mid||m.ts)}` : null);
      if (img && m.kind === 'image'){ 
        // base64 이미지는 직접 src로 설정되므로 일반적으로 오류가 발생하지 않음
        img.onerror = ()=>{ 
          console.error('이미지 로드 실패:', m.mediaUrl?.substring(0, 50) + '...');
          const errorDiv = document.createElement('div');
          errorDiv.style.cssText = 'padding:8px; text-align:center; color:#666; border:1px dashed #ccc; border-radius:8px;';
          errorDiv.textContent = '이미지를 불러올 수 없습니다';
          img.replaceWith(errorDiv);
        };
      }

      if (stayAtBottom) {
        ScrollManager.scrollToBottom(false);
      }
      
      // 🚀 새로 추가된 이미지 관찰 등록
      LazyImageManager.observeImages();
    }

    /* ===== 데이터 관리 ===== */
    const DataManager = {
      // 과거 메시지 로드 (무한 스크롤용)
      loadPastMessages: async () => {
        if (!AppState.userId) return false;
        
        const roomData = AppState.cache.pagination?.[AppState.currentRoom];
        if (!roomData || !roomData.hasMore || !roomData.oldestTimestamp) {
          console.log('더 이상 로드할 과거 메시지가 없습니다.');
          return false;
        }
        
        try {
          const response = await apiCall('GET', `/api/messages/${AppState.currentRoom}?before=${roomData.oldestTimestamp}&limit=100`);
          const messages = response?.messages || [];
          const hasMore = response?.hasMore || false;
          const oldestTs = response?.oldestTimestamp || null;
          
          if (messages && messages.length > 0) {
            // 스크롤 위치 보존을 위해 현재 상태 저장
            const savedPosition = ScrollManager.saveScrollPosition();
            
            // 메시지들을 맨 위에 추가 (시간 순서대로)
            messages.forEach(msg => {
              if (!AppState.cache.renderedMids[AppState.currentRoom].has(msg.mid)) {
                const messageDiv = UI.messageDiv(msg, false); // 스크롤 없이 추가
                messagesEl.insertBefore(messageDiv, messagesEl.firstChild);
                AppState.cache.renderedMids[AppState.currentRoom].set(msg.mid, msg);
              }
            });
            
            // 페이징 정보 업데이트
            AppState.cache.pagination[AppState.currentRoom] = {
              hasMore: hasMore,
              oldestTimestamp: oldestTs
            };
            
            // 스크롤 위치 복원 (새로 추가된 메시지만큼 아래로 이동)
            ScrollManager.restoreScrollPosition(savedPosition);
            
            // 🚀 새로 로드된 과거 이미지들 관찰 등록
            LazyImageManager.observeImages();
            
            console.log(`과거 메시지 ${messages.length}개 로드 완료`);
            return true;
          }
          return false;
        } catch (error) {
          console.error('과거 메시지 로드 실패:', error);
          return false;
        }
      },

      fetchAndRender: async (forceScroll, fullReload = false) => {
        if(!AppState.userId) return;
        
        try {
          // 방 전환 시에는 전체 메시지 다시 로드, 아니면 증분 로드
          const since = fullReload ? 0 : (AppState.cache.lastTs[AppState.currentRoom] || 0);
          const response = await apiCall('GET', `/api/messages/${AppState.currentRoom}?since=${since}`);
          
          // 새로운 API 응답 구조 처리
          const messages = response?.messages || response || []; // 하위 호환성 유지
          const hasMore = response?.hasMore || false;
          const oldestTs = response?.oldestTimestamp || null;
          
          // 🚀 로딩 스켈레톤 제거
          if (fullReload) {
            const loadingSkeleton = messagesEl.querySelector('.loading-skeleton');
            if (loadingSkeleton) {
              messagesEl.removeChild(loadingSkeleton);
            }
          }
          
          if(messages && messages.length){
            messages.forEach(addOrUpdateMsg);
            AppState.cache.lastTs[AppState.currentRoom] = Math.max(AppState.cache.lastTs[AppState.currentRoom]||0, messages[messages.length-1].ts||0);
            
            // 무한 스크롤 메타데이터 저장
            if (!AppState.cache.pagination) AppState.cache.pagination = {};
            AppState.cache.pagination[AppState.currentRoom] = {
              hasMore: hasMore,
              oldestTimestamp: oldestTs
            };
            
            if (forceScroll) {
              ScrollManager.scrollToBottom(false);
            }
          }
          
          // 더 보기 버튼 상태 업데이트
          MessageManager.updateLoadMoreButton();
          
          // 🚀 새로 로드된 이미지들 관찰 등록
          LazyImageManager.observeImages();
          
          const t = new Date().toLocaleTimeString();
          DOM.el('#topStatus').textContent = `연결됨 · ${t}`;
        } catch (error) {
          console.error(error);
          DOM.el('#topStatus').textContent = '연결 끊김';
        }
      }
    };

    /* ===== 메시지 관리자 ===== */
    const MessageManager = {
      observer: null,
      isLoading: false,

      // 더 보기 버튼 상태 업데이트
      updateLoadMoreButton: () => {
        const btn = DOM.el('#loadMoreBtn');
        const roomData = AppState.cache.pagination?.[AppState.currentRoom];
        
        if (roomData && roomData.hasMore) {
          btn.style.display = 'flex';
        } else {
          btn.style.display = 'none';
        }
      },

      // Intersection Observer 초기화
      initIntersectionObserver: () => {
        if (!window.IntersectionObserver) {
          console.warn('Intersection Observer를 지원하지 않는 브라우저입니다.');
          return;
        }

        const loadMoreBtn = DOM.el('#loadMoreBtn');
        
        MessageManager.observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting && !MessageManager.isLoading) {
              const roomData = AppState.cache.pagination?.[AppState.currentRoom];
              if (roomData && roomData.hasMore) {
                MessageManager.loadPastMessagesAuto();
              }
            }
          });
        }, {
          root: DOM.el('#messages'),
          rootMargin: '20px',
          threshold: 0.1
        });

        if (loadMoreBtn) {
          MessageManager.observer.observe(loadMoreBtn);
        }
      },

      // 자동 로드 (Intersection Observer 용)
      loadPastMessagesAuto: async () => {
        if (MessageManager.isLoading) return;
        
        MessageManager.isLoading = true;
        console.log('[AUTO-LOAD] 과거 메시지 자동 로드 시작');

        try {
          const success = await DataManager.loadPastMessages();
          if (success) {
            MessageManager.updateLoadMoreButton();
          }
        } catch (error) {
          console.error('자동 로드 실패:', error);
        } finally {
          MessageManager.isLoading = false;
        }
      },

      // 방 전환 시 버튼 상태 초기화 및 Observer 재설정
      onRoomSwitch: () => {
        MessageManager.updateLoadMoreButton();
        
        // Observer 재설정 (새로운 버튼에 대해)
        if (MessageManager.observer) {
          MessageManager.observer.disconnect();
        }
        
        setTimeout(() => {
          MessageManager.initIntersectionObserver();
        }, 100); // DOM 업데이트 후 Observer 재설정
      }
    };
    
    // 레거시 지원
    async function fetchAndRender(forceScroll){
      return DataManager.fetchAndRender(forceScroll);
    }
    

    async function initMe(){
      try {
        const u = await apiCall('POST', `/api/user/${AppState.userId}`);
        AppState.me = u;
        
        // 안전한 DOM 요소 업데이트 - 존재하는 요소들만 업데이트
        const nicknameView = DOM.el('#nicknameView');
        const statusView = DOM.el('#statusView');
        const topStatus = DOM.el('#topStatus');
        
        if (nicknameView) nicknameView.textContent = u.nickname || 'User';
        if (statusView) statusView.textContent = u.status || '상태메시지…';
        if (topStatus) topStatus.textContent = (u.nickname || 'User') + (u.status ? ` — ${u.status}` : '');
        
        // 프로필 이미지 설정 (아바타 이미지 요소가 있는 경우)
        setAvatar(u.avatar || '');
        UI.drawTabs();
        
        // 🚀 이미지 지연 로딩 시스템 초기화
        LazyImageManager.init();
        
        DataManager.fetchAndRender(true);
        
        console.log('[INFO] 사용자 정보 로드 완료:', u.nickname);
      } catch (error) {
        console.error('사용자 정보 로드 실패:', error);
      }
    }

    /* ===== Send / Upload ===== */
    async function sendText(){
      if(!AppState.userId || AppState.flags.sending) return;
      const t = DOM.el('#text');
      const v = Utils.sanitizeInput(t.value);
      if(!v) return;

      // 🔔 첫 메시지 전송 시 알림 권한 자동 요청
      if (Notification.permission === 'default' && !AppState.notifications.permissionRequested) {
        console.log('🔔 첫 메시지 전송 - 알림 권한 요청');
        AppState.notifications.permissionRequested = true;
        
        try {
          const permission = await notificationManager.requestPermission();
          if (permission === 'granted') {
            console.log('✅ 알림 권한 허용됨 - Push 시스템 초기화');
            notificationManager.initializePush();
          }
        } catch (error) {
          console.warn('⚠️ 알림 권한 요청 실패:', error);
        }
      }

      const sendRoom = AppState.currentRoom;
      AppState.flags.sending = true;
      Utils.setButtonLoading(DOM.el('#sendBtn'), true);
      const mid = Utils.generateMessageId();

      try {
        const requestBody = {
          room: sendRoom,
          userId: AppState.userId,
          text: v,
          mid
        };
        
        // 🔗 답글 정보 추가
        if (AppState.reply.active && AppState.reply.targetMid) {
          requestBody.replyTo = AppState.reply.targetMid;
        }
        
        const result = await apiCall('POST', '/api/messages', requestBody);
        
        AppState.flags.sending = false;
        Utils.setButtonLoading(DOM.el('#sendBtn'), false);
        t.value = '';
        
        // 🔗 답글 모드 종료
        if (AppState.reply.active) {
          ReplyManager.cancelReply();
        }
        
        AppState.cache.lastTs[sendRoom] = Math.max(AppState.cache.lastTs[sendRoom]||0, result.ts||0);
        if (AppState.currentRoom !== sendRoom) return;
        // 실시간으로 이미 받았을 수 있으므로 중복 체크 후 추가
        if (!AppState.cache.renderedMids[sendRoom].has(result.mid)) {
          addOrUpdateMsg(result);
        }
        beep();
      } catch (error) {
        AppState.flags.sending = false;
        Utils.setButtonLoading(DOM.el('#sendBtn'), false);
        alert('전송 실패: '+error.message);
      }
    }

    /* ===== Logout ===== */
    function doLogout(){
      socket.emit('leaveRoom', AppState.currentRoom);
      AppState.userId=null; AppState.me=null;
      messagesEl.innerHTML='';
      Object.keys(AppState.cache.renderedMids).forEach(room => AppState.cache.renderedMids[room].clear());
      Object.keys(AppState.cache.lastTs).forEach(k=> AppState.cache.lastTs[k]=0);
      Object.keys(AppState.cache.lastDayRendered).forEach(k=> AppState.cache.lastDayRendered[k]='');
      setAvatar('');
      // 안전한 DOM 요소 초기화 - 존재하는 요소들만 업데이트
      const nicknameView = DOM.el('#nicknameView');
      const statusView = DOM.el('#statusView');
      const topStatus = DOM.el('#topStatus');
      
      if (nicknameView) nicknameView.textContent = 'User';
      if (statusView) statusView.textContent = '상태메시지…';
      if (topStatus) topStatus.textContent = '—';
      enableUI(false);

      DOM.el('#loginName').value='';
      DOM.el('#loginBirth').value='';
      DOM.el('#auth').classList.remove('hidden');
      document.body.classList.add('auth-open');

      document.body.classList.remove('profile-open');
      hideProfileModal();
      
      // 접속자 목록 초기화
      ConnectedUsersUI.setUsers([]);
    }

    function bindUI(){
      console.log('[UI] bindUI 함수 시작 - 안전한 이벤트 바인딩 적용');
      
      try {
        // iOS Safari 실제 디바이스 터치 호환성 강화
        const sendBtnElement = DOM.el('#sendBtn');
        console.log('[UI] #sendBtn 요소 검색 결과:', sendBtnElement ? '발견됨' : '없음');
        
        // User-Agent 및 디바이스 감지
        const isIOSSafari = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        console.log('[디바이스] iOS Safari 감지:', isIOSSafari);
        console.log('[디바이스] 모바일 디바이스:', isMobileDevice);
        console.log('[디바이스] 터치 지원:', isTouch);
        
        if (sendBtnElement) {
          // CSS 터치 최적화 (iOS Safari 전용)
          sendBtnElement.style.touchAction = 'manipulation';
          sendBtnElement.style.userSelect = 'none';
          sendBtnElement.style.webkitUserSelect = 'none';
          sendBtnElement.style.webkitTouchCallout = 'none';
          sendBtnElement.style.webkitTapHighlightColor = 'transparent';
          
          // iOS Safari 최소 터치 타겟 크기 보장 (44x44px)
          const btnRect = sendBtnElement.getBoundingClientRect();
          console.log('[터치타겟] 버튼 크기:', btnRect.width, 'x', btnRect.height);
          
          let touchStarted = false;
          let touchProcessing = false;
          let lastTouchTime = 0;
          let touchStartCoords = null;
          
          // iOS Safari 전용 터치 이벤트 시퀀스
          // iOS Safari는 터치 지원 감지와 관계없이 터치 이벤트 바인딩 (실제 디바이스 호환성)
          if (isIOSSafari) {
            console.log('[iOS터치] iOS Safari 감지됨 - 터치 이벤트 강제 바인딩');
            
            // 터치 시작 감지
            sendBtnElement.addEventListener('touchstart', (e) => {
              touchStarted = true;
              touchProcessing = false;
              
              // 터치 시작 좌표 저장 (스와이프 필터링용)
              if (e.touches && e.touches[0]) {
                touchStartCoords = {
                  x: e.touches[0].clientX,
                  y: e.touches[0].clientY
                };
              }
              
              console.log('[iOS터치] touchstart 감지 - 좌표:', touchStartCoords);
              
              // iOS Safari 시각적 피드백
              sendBtnElement.style.opacity = '0.7';
              
            }, { passive: true });
            
            // 터치 이동 감지 (스와이프 취소)
            sendBtnElement.addEventListener('touchmove', (e) => {
              if (!touchStarted || !touchStartCoords) return;
              
              if (e.touches && e.touches[0]) {
                const currentCoords = {
                  x: e.touches[0].clientX,
                  y: e.touches[0].clientY
                };
                
                const distance = Math.sqrt(
                  Math.pow(currentCoords.x - touchStartCoords.x, 2) + 
                  Math.pow(currentCoords.y - touchStartCoords.y, 2)
                );
                
                // 10px 이상 이동시 터치 취소
                if (distance > 10) {
                  console.log('[iOS터치] 터치 이동 감지 - 취소:', distance + 'px');
                  touchStarted = false;
                  sendBtnElement.style.opacity = '';
                }
              }
            }, { passive: true });
            
            // 터치 완료 처리
            sendBtnElement.addEventListener('touchend', (e) => {
              // 시각적 피드백 복원
              sendBtnElement.style.opacity = '';
              
              if (!touchStarted) {
                console.log('[iOS터치] touchstart 없이 touchend 감지 - 무시');
                return;
              }
              
              // iOS Safari 고스트 클릭 방지
              e.preventDefault();
              e.stopPropagation();
              e.stopImmediatePropagation();
              
              touchStarted = false;
              touchProcessing = true;
              lastTouchTime = Date.now();
              
              console.log('[iOS터치] touchend 처리 - 메시지 전송 시작');
              
              // iOS Safari 안전한 비동기 실행
              setTimeout(() => {
                try {
                  sendText();
                  console.log('[iOS터치] 메시지 전송 완료');
                } catch (error) {
                  console.error('[iOS터치] 전송 오류:', error);
                }
              }, 0);
              
              // 터치 처리 상태 초기화
              setTimeout(() => {
                touchProcessing = false;
              }, 500); // iOS Safari용 더 긴 대기시간
              
            }, { passive: false });
            
            // 터치 취소 처리
            sendBtnElement.addEventListener('touchcancel', (e) => {
              console.log('[iOS터치] touchcancel 감지');
              touchStarted = false;
              touchProcessing = false;
              sendBtnElement.style.opacity = '';
            }, { passive: true });
            
            console.log('[iOS터치] iOS Safari 전용 터치 이벤트 바인딩 완료');
            
          } else if (isMobileDevice && isTouch) {
            // 다른 모바일 디바이스 (Android 등)의 터치 이벤트
            console.log('[터치] 모바일 디바이스 터치 이벤트 바인딩');
            
            sendBtnElement.addEventListener('touchstart', (e) => {
              touchStarted = true;
              touchProcessing = false;
              console.log('[터치] touchstart 감지 - 안드로이드/기타 모바일');
              sendBtnElement.style.opacity = '0.7';
            }, { passive: true });
            
            sendBtnElement.addEventListener('touchend', (e) => {
              sendBtnElement.style.opacity = '';
              if (!touchStarted) return;
              
              e.preventDefault();
              e.stopPropagation();
              
              touchStarted = false;
              touchProcessing = true;
              lastTouchTime = Date.now();
              
              console.log('[터치] touchend 처리 - 메시지 전송');
              setTimeout(() => {
                sendText();
                setTimeout(() => { touchProcessing = false; }, 300);
              }, 0);
            }, { passive: false });
            
          } else {
            // 데스크톱 환경의 클릭 이벤트
            console.log('[클릭] 데스크톱 클릭 이벤트 바인딩');
            sendBtnElement.addEventListener('click', (e) => {
              console.log('[클릭] 데스크톱 클릭 이벤트 처리');
              sendText();
            });
          }
          
          // iOS Safari 전용 클릭 이벤트 폴백 (Ghost Click 방지)
          if (isIOSSafari) {
            // iOS Safari에서 클릭 이벤트 고스트 클릭 방지
            sendBtnElement.addEventListener('click', (e) => {
              if (touchProcessing || (Date.now() - lastTouchTime < 500)) {
                console.log('[iOS터치] Ghost Click 방지됨 - 터치 이벤트 우선');
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return false;
              }
              
              // 터치 이벤트가 없었다면 클릭으로 처리 (접근성)
              console.log('[iOS클릭] 터치 없는 클릭 이벤트 처리 (접근성)');
              sendText();
            });
          }
          
          console.log('[UI] iOS Safari 실제 디바이스 호환 이벤트 바인딩 완료');
        } else {
          console.error('[UI] sendBtn 요소를 찾을 수 없습니다');
        }
        
        const textElement = DOM.el('#text');
        if (textElement) {
          textElement.addEventListener('keydown', e => { 
            if (e.key === 'Enter' && !e.shiftKey) { 
              e.preventDefault(); 
              sendText(); 
            } 
          });
        } else {
          console.warn('[UI] text 입력 요소를 찾을 수 없습니다');
        }

        // 프로필 저장 - 안전한 바인딩과 에러 처리 강화
        const saveBtn = DOM.el('#saveBtn');
        if (saveBtn) {
          saveBtn.onclick = async () => {
            try {
              // Fail Fast 원칙: 조기 검증
              if (!AppState.userId) {
                console.warn('[프로필] 사용자 ID가 없습니다');
                return;
              }

              // 안전한 DOM 요소 접근
              const nicknameEl = DOM.el('#nickname');
              const statusEl = DOM.el('#status');
              const avatarEl = DOM.el('#avatar');
              const clearAvEl = DOM.el('#clearAvatar');
              
              if (!nicknameEl || !statusEl || !avatarEl || !clearAvEl) {
                throw new Error('프로필 폼 요소를 찾을 수 없습니다');
              }

              const nickname = nicknameEl.value;
              const status = statusEl.value;
              const avValue = (avatarEl.value || '').trim();
              const clearAv = clearAvEl.checked;

              const profile = { nickname, status };
              if (clearAv) profile.clearAvatar = true;   
              if (avValue) profile.avatar = avValue;     

              console.log('[프로필] 저장 시도:', profile);
              const u = await apiCall('PUT', `/api/profile/${AppState.userId}`, profile);
              
              // 안전한 UI 업데이트
              AppState.me = u;
              const nicknameView = DOM.el('#nicknameView');
              const statusView = DOM.el('#statusView');
              const topStatus = DOM.el('#topStatus');
              
              if (nicknameView) nicknameView.textContent = u.nickname || 'User';
              if (statusView) statusView.textContent = u.status || '상태메시지…';
              if (topStatus) topStatus.textContent = (u.nickname || 'User') + (u.status ? ` — ${u.status}` : '');
              
              setAvatar(u.avatar || '');
              if (avatarEl) avatarEl.value = u.avatar || '';
              if (clearAvEl) clearAvEl.checked = false;
              
              // 접속자 정보 업데이트 알림
              if (socket && socket.emit) {
                socket.emit('userProfileUpdated', {
                  userId: AppState.userId,
                  nickname: u.nickname,
                  avatar: u.avatar,
                  status: u.status
                });
              }
              
              console.log('[프로필] 저장 성공');
              beep();
            } catch (error) {
              console.error('[프로필] 저장 실패:', error);
              alert('저장 실패: ' + error.message);
            }
          };
        } else {
          console.warn('[UI] saveBtn 요소를 찾을 수 없습니다');
        }

        // 아바타 입력 시 "지우기" 자동 해제 - 안전한 바인딩
        const avatarInput = DOM.el('#avatar');
        const clearAvatarCheckbox = DOM.el('#clearAvatar');
        if (avatarInput && clearAvatarCheckbox) {
          avatarInput.addEventListener('input', () => {
            if ((avatarInput.value || '').trim()) {
              clearAvatarCheckbox.checked = false;
            }
          });
        } else {
          console.warn('[UI] 아바타 입력 요소를 찾을 수 없습니다');
        }

        // 사진 업로드 - 안전한 바인딩
        const photoBtn = DOM.el('#photoBtn');
        const imageInput = DOM.el('#image');
        
        if (photoBtn && imageInput) {
          let photoTouchStarted = false;
          let photoTouchProcessing = false;
          let photoLastTouchTime = 0;
          
          const handlePhotoClick = () => {
            if (AppState.userId) {
              console.log('[사진] 파일 선택 다이얼로그 열기');
              imageInput.click(); 
            } else {
              console.warn('[업로드] 로그인이 필요합니다');
            }
          };
          
          // iOS Safari 터치 시퀀스 처리 (사진 버튼)
          photoBtn.addEventListener('touchstart', (e) => {
            photoTouchStarted = true;
            photoTouchProcessing = false;
            console.log('[사진터치] touchstart 감지');
          }, { passive: true });
          
          photoBtn.addEventListener('touchend', (e) => {
            if (!photoTouchStarted) return;
            
            e.preventDefault(); // Ghost Click 방지
            e.stopPropagation(); // 이벤트 버블링 차단
            
            photoTouchStarted = false;
            photoTouchProcessing = true;
            photoLastTouchTime = Date.now();
            
            console.log('[사진터치] touchend 처리 - 파일 다이얼로그');
            handlePhotoClick();
            
            // 터치 처리 상태 초기화
            setTimeout(() => {
              photoTouchProcessing = false;
            }, 300);
          }, { passive: false });
          
          // 마우스/클릭 이벤트 처리 (데스크톱 호환성)
          photoBtn.addEventListener('click', (e) => {
            // 최근 터치 이벤트가 있었다면 클릭 무시 (Ghost Click 방지)
            if (photoTouchProcessing || (Date.now() - photoLastTouchTime < 300)) {
              console.log('[사진터치] Ghost Click 방지됨');
              e.preventDefault();
              return;
            }
            
            console.log('[사진클릭] 데스크톱 클릭 이벤트 처리');
            handlePhotoClick();
          });
          
          imageInput.addEventListener('change', async () => {
            try {
              const f = imageInput.files[0];
              
              // Fail Fast 원칙: 조기 검증
              if (!AppState.userId || !f || AppState.flags.uploading) {
                console.log('[업로드] 업로드 조건 불충족');
                return;
              }
              
              if (f.size > 10 * 1024 * 1024) { 
                alert('10MB 이하만 업로드 가능합니다.'); 
                imageInput.value = ''; 
                return; 
              }

              const uploadRoom = AppState.currentRoom;
              AppState.flags.uploading = true;
              
              // 안전한 버튼 비활성화
              if (photoBtn) photoBtn.disabled = true;
              
              const mid = Utils.generateMessageId();
              console.log('[업로드] 이미지 처리 시작:', f.name, `원본: ${(f.size/1024/1024).toFixed(2)}MB`);
              
              // 이미지 압축 및 최적화 처리
              const optimizedImage = await optimizeImage(f);
              console.log('[압축] 이미지 최적화 완료:', `압축후: ${(optimizedImage.size/1024).toFixed(2)}KB`, `압축률: ${((1 - optimizedImage.size/f.size) * 100).toFixed(1)}%`);
              
              // 최적화된 이미지를 base64로 변환
              const base64Data = optimizedImage.dataUrl;

          const requestBody = {
            room: uploadRoom,
            userId: AppState.userId,
            mid: mid,
            imageData: base64Data,
            fileName: f.name,
            mimeType: f.type
          };

          const response = await fetch('/api/upload', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody)
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || '업로드 실패');
          }

              const result = await response.json();
              
              // 안전한 상태 복원
              AppState.flags.uploading = false;
              if (photoBtn) photoBtn.disabled = false;
              imageInput.value = '';
              
              AppState.cache.lastTs[uploadRoom] = Math.max(AppState.cache.lastTs[uploadRoom] || 0, result.ts || 0);
              if (AppState.currentRoom !== uploadRoom) return;
              if (!AppState.cache.renderedMids[uploadRoom].has(result.mid)) {
                addOrUpdateMsg(result);
              }
              
              console.log('[업로드] 업로드 성공:', result.mid);
              beep();
            } catch (error) {
              console.error('[업로드] 업로드 실패:', error);
              
              // 안전한 상태 복원
              AppState.flags.uploading = false;
              if (photoBtn) photoBtn.disabled = false;
              imageInput.value = '';
              
              alert('업로드 실패: ' + error.message);
            }
          });
        } else {
          console.warn('[UI] 사진 업로드 요소를 찾을 수 없습니다');
        }

        // 나머지 UI 바인딩 - 안전한 바인딩
        if (!DOM.safeAssign('#startBtn', 'onclick', doLogin)) {
          console.error('[UI] startBtn 바인딩 실패');
        }
        
        if (!DOM.safeAssign('#logoutBtn', 'onclick', doLogout)) {
          console.error('[UI] logoutBtn 바인딩 실패');
        }
        
        // 답글 취소 버튼
        const cancelReplyBtn = el('#cancelReply');
        if (cancelReplyBtn) {
          cancelReplyBtn.onclick = () => ReplyManager.cancelReply();
        } else {
          console.warn('[UI] cancelReply 버튼을 찾을 수 없습니다');
        }
        
        // 무한 스크롤 - 100개 더 보기 버튼
        el('#loadMoreBtn').onclick = async () => {
          const btn = DOM.el('#loadMoreBtn');
          const textSpan = DOM.el('.load-more-text');
          const spinnerSpan = DOM.el('.load-more-spinner');
          
          btn.disabled = true;
          textSpan.style.display = 'none';
          spinnerSpan.style.display = 'inline';
          
          try {
            const success = await DataManager.loadPastMessages();
            if (success) {
              MessageManager.updateLoadMoreButton();
            }
          } catch (error) {
            console.error('과거 메시지 로드 실패:', error);
          } finally {
            btn.disabled = false;
            textSpan.style.display = 'inline';
            spinnerSpan.style.display = 'none';
          }
        };

        // Retro toggle
        el('#toggle98').addEventListener('click', ()=>{ applyTheme98(!document.body.classList.contains('win98')); beep(); });

        // 프로필 모달 기본 동작
        bindProfileModalBasics();

        // 드래그 가능한 로그인 다이얼로그
        makeDialogDraggable('#dialogCard','#dlgDragHandle');

        // 리사이즈 시 탭 라벨/상태 갱신
        let lastCompact = UI.isCompact();
        window.addEventListener('resize', ()=>{
          const nowCompact = UI.isCompact();
          if (nowCompact !== lastCompact){
            UI.drawTabs(); UI.setActiveTabUI();
            lastCompact = nowCompact;
          }
        });
        
        // 이미지 클릭 확대 보기 이벤트 바인딩
        bindImageZoomEvents();
        
        console.log('[UI] bindUI 함수 완료 - 모든 이벤트 바인딩 안전하게 처리됨');
        
      } catch (error) {
        console.error('[UI] bindUI 함수 오류:', error);
        throw error; // Re-throw to ensure caller knows about the error
      }
    }

    /* ===== Login - 현대적인 에러 처리와 상태 관리 ===== */
    async function doLogin(){
      console.log('[로그인] 로그인 프로세스 시작');
      
      try {
        // DOM 요소들을 안전하게 가져오기
        const loginBtn = DOM.el('#startBtn');
        const card = DOM.el('#dialogCard');
        const nameInput = DOM.el('#loginName');
        const birthInput = DOM.el('#loginBirth');
        const authDiv = DOM.el('#auth');

        // Fail Fast: 필수 요소 검증
        if (!loginBtn || !nameInput || !birthInput || !authDiv) {
          throw new Error('로그인 폼 요소를 찾을 수 없습니다');
        }

        // 로그인 버튼 비활성화
        loginBtn.disabled = true;
        loginBtn.textContent = '로그인 중...';

        // 입력값 검증
        const name = (nameInput.value || '').trim();
        const b4 = (birthInput.value || '').replace(/\D/g, '').slice(0, 4);
        
        if (!name || b4.length !== 4) { 
          console.warn('[로그인] 입력값 검증 실패:', { name: !!name, birth4Length: b4.length });
          
          // 시각적 피드백
          if (card) {
            card.classList.remove('shake'); 
            void card.offsetWidth; // Force reflow
            card.classList.add('shake'); 
          }
          
          // 상태 복원
          loginBtn.disabled = false;
          loginBtn.textContent = '시작하기';
          return; 
        }

        console.log('[로그인] API 호출 시작:', { name, birth4: b4 });
        const u = await apiCall('POST', '/api/login', { name, birth4: b4 });
        
        if (!u || !u.id) {
          throw new Error('서버에서 유효하지 않은 응답을 받았습니다');
        }

        // 로그인 성공 - 상태 업데이트
        console.log('[로그인] 로그인 성공:', { userId: u.id, name: u.nickname });
        AppState.userId = u.id;
        
        // 🔒 관리자 권한 체크 (나우창 + 0809)
        const isAdmin = (u.nickname === '나우창' && nameInput.value === '나우창' && birthInput.value === '0809');
        AppState.isAdmin = isAdmin;
        
        if (isAdmin) {
          console.log('👑 관리자 로그인 - 특별 권한 활성화');
        }
        
        // UI 상태 변경
        authDiv.classList.add('hidden'); 
        document.body.classList.remove('auth-open');
        enableUI(true); 
        UI.drawTabs(); 
        
        // 사용자 정보 초기화
        await initMe();
        
        // 소켓 연결
        if (socket && socket.emit) {
          socket.emit('joinRoom', AppState.currentRoom);
          socket.emit('userLogin', { userId: AppState.userId });
        } else {
          console.warn('[로그인] 소켓이 연결되지 않았습니다');
        }
        
        console.log('[로그인] 로그인 프로세스 완료');
        beep();

      } catch (error) {
        console.error('[로그인] 로그인 실패:', error);
        
        // 사용자에게 명확한 에러 메시지 제공
        let userMessage = '로그인에 실패했습니다.';
        if (error.message.includes('네트워크')) {
          userMessage = '네트워크 연결을 확인해주세요.';
        } else if (error.message.includes('서버')) {
          userMessage = '서버와의 통신에 문제가 있습니다.';
        } else if (error.message.includes('유효하지 않은')) {
          userMessage = '로그인 정보가 올바르지 않습니다.';
        }
        
        alert(userMessage + '\n\n기술적 세부사항: ' + error.message);
        
      } finally {
        // 상태 복원 - 안전한 처리
        const loginBtn = DOM.el('#startBtn');
        if (loginBtn) {
          loginBtn.disabled = false;
          loginBtn.textContent = '시작하기';
        }
      }
    }

    // Dialog drag helper
    function makeDialogDraggable(cardSel, handleSel){
      const card = el(cardSel), handle = el(handleSel); if(!card||!handle) return;
      let sx=0, sy=0, ox=0, oy=0, dragging=false;
      const down=(e)=>{ dragging=true; const r=card.getBoundingClientRect(); ox=r.left; oy=r.top; sx=e.clientX; sy=e.clientY; handle.style.cursor='grabbing'; e.preventDefault(); };
      const move=(e)=>{ if(!dragging) return; const dx=e.clientX-sx, dy=e.clientY-sy; card.style.position='fixed'; card.style.left=(ox+dx)+'px'; card.style.top=(oy+dy)+'px'; };
      const up=()=>{ dragging=false; handle.style.cursor='grab'; };
      handle.addEventListener('mousedown',down); window.addEventListener('mousemove',move); window.addEventListener('mouseup',up);
    }

    // Socket.io 이벤트 핸들러 - 강화된 필터링 + 알림 통합
    socket.on('newMessage', (message) => {
      // 🔔 알림 처리 (모든 메시지에 대해)
      if (AppState.userId && message.room) {
        notificationManager.handleNewMessage(message, message.room);
      }
      
      // 강화된 방 검증: 현재 방과 완전히 일치하고 사용자가 로그인된 상태인 경우만 처리
      if (message.room === AppState.currentRoom && AppState.userId && !AppState.flags.switching) {
        addOrUpdateMsg(message);
        AppState.cache.lastTs[AppState.currentRoom] = Math.max(AppState.cache.lastTs[AppState.currentRoom] || 0, message.ts || 0);
      }
      // 다른 방 메시지나 방 전환 중인 메시지는 완전 무시
    });

    socket.on('reactionUpdate', (message) => {
      // 반응 업데이트도 동일한 검증 적용
      if (message.room === AppState.currentRoom && AppState.userId && !AppState.flags.switching) {
        updateReactsView(message);
      }
    });

    // 👑 관리자 메시지 삭제 이벤트
    socket.on('messageDeleted', (data) => {
      const { mid, adminId, room } = data;
      
      if (room === AppState.currentRoom) {
        // UI에서 메시지 제거
        const messageRow = document.querySelector(`[data-message-id="${mid}"]`);
        if (messageRow) {
          messageRow.style.opacity = '0.3';
          messageRow.style.transform = 'translateX(-20px)';
          
          setTimeout(() => {
            messageRow.remove();
            
            // 캐시에서도 제거
            AppState.cache.renderedMids[AppState.currentRoom].delete(mid);
            
            console.log(`[Socket] 관리자에 의해 메시지가 삭제됨: ${mid}`);
          }, 300);
        }
        
        // 관리자가 아닌 사용자에게 알림 표시
        if (AppState.userId !== adminId) {
          console.log('🗑️ 관리자에 의해 메시지가 삭제되었습니다.');
        }
      }
    });

    // ===== 접속자 관련 Socket 이벤트 =====
    socket.on('connectedUsersList', (data) => {
      ConnectedUsersUI.setUsers(data.users || []);
    });

    socket.on('userConnected', (user) => {
      ConnectedUsersUI.addUser(user);
    });

    socket.on('userDisconnected', (data) => {
      ConnectedUsersUI.removeUser(data.userId);
    });

    socket.on('userProfileUpdated', (user) => {
      ConnectedUsersUI.updateUser(user);
    });

    // 업무 상태 변경 실시간 동기화 처리
    socket.on('userWorkStatusUpdated', (data) => {
      console.log(`🔄 업무 상태 변경 수신:`, data);
      
      // 접속자 목록에서 해당 사용자 찾기
      const existingIndex = AppState.connectedUsers.findIndex(u => u.userId === data.userId);
      if (existingIndex >= 0) {
        // 기존 사용자의 업무 상태만 업데이트 (프로필 상태는 유지)
        AppState.connectedUsers[existingIndex] = { 
          ...AppState.connectedUsers[existingIndex], 
          workStatus: data.status  // workStatus 필드로 업무 상태 저장
        };
        
        // 접속자 목록 다시 렌더링
        ConnectedUsersUI.render(AppState.connectedUsers);
        
        console.log(`✅ 접속자 ${data.nickname}의 업무 상태가 ${data.status}로 업데이트됨`);
      } else {
        console.warn(`⚠️ 접속자 목록에서 사용자 ${data.userId}를 찾을 수 없음`);
      }
    });

    /* ===== iOS 주소창 높이 변동 대응용 --vh 세팅 ===== */
    (function setVhUnit(){
      const setVh = () => {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
      };
      setVh();
      window.addEventListener('resize', setVh, {passive:true});
      window.addEventListener('orientationchange', setVh, {passive:true});
    })();

    // ===== Boot =====
    (function boot(){
      enableUI(false);
      // 로그인 자동완성 방지 + 항상 빈칸
      const ln=el('#loginName'), lb=el('#loginBirth');
      ln.name='n_'+Math.random().toString(36).slice(2); lb.name='b_'+Math.random().toString(36).slice(2);
      ln.value=''; lb.value='';
      restoreTheme98(); // 테마 복원
      attachBeepTo('.tab,.btn,.chip,.add-react,.pick');
      
      // 무한 스크롤 Intersection Observer 초기화
      MessageManager.initIntersectionObserver();
      
      // 🔔 NotificationManager 초기화
      notificationManager.init();
      setupNotificationUI();
    })();

    /* ===== 🔔 알림 설정 UI 핸들러 ===== */
    function setupNotificationUI() {
      const elements = {
        requestBtn: el('#requestNotificationBtn'),
        permissionRequestArea: el('#permissionRequestArea'),
        permissionDeniedArea: el('#permissionDeniedArea'),
        // 모든 UI 요소 제거됨 - 기본 알림만 사용
      };

      // UI 상태 업데이트
      function updateUI() {
        const { settings, permission } = AppState.notifications;
        
        // 권한 상태에 따른 UI 조정 (null 체크 추가)
        if (permission === 'denied' || !('Notification' in window)) {
          // 권한이 거부되었거나 지원되지 않는 경우
          if (elements.permissionRequestArea) elements.permissionRequestArea.style.display = 'none';
          if (elements.permissionDeniedArea) elements.permissionDeniedArea.style.display = 'block';
          // 브라우저 알림 체크박스 제거됨
        } else if (permission === 'default') {
          // 권한이 아직 요청되지 않은 경우
          if (elements.permissionRequestArea) elements.permissionRequestArea.style.display = 'block';
          if (elements.permissionDeniedArea) elements.permissionDeniedArea.style.display = 'none';
          // 브라우저 알림 체크박스 제거됨
        } else if (permission === 'granted') {
          // 권한이 허용된 경우
          if (elements.permissionRequestArea) elements.permissionRequestArea.style.display = 'none';
          if (elements.permissionDeniedArea) elements.permissionDeniedArea.style.display = 'none';
          // 브라우저 알림 체크박스 제거됨
        }
        
        // 체크박스 제거됨 - 모든 알림 항상 활성
        
        // 소리 설정 UI 제거됨 - 기본값 사용
      }

      // 설정 저장 헬퍼
      function saveAndUpdate() {
        notificationManager.saveSettings();
        updateUI();
      }

      // 🔔 권한 요청
      elements.requestBtn?.addEventListener('click', async () => {
        elements.requestBtn.disabled = true;
        elements.requestBtn.innerHTML = '<span class="spinner"></span> 요청 중...';
        
        const permission = await notificationManager.requestPermission();
        
        // 권한 요청 결과에 따른 피드백
        if (permission === 'granted') {
          elements.requestBtn.innerHTML = '✅ 허용됨';
          // 오디오 초기화도 시도
          await notificationManager.initializeAudio();
          
          // 테스트 알림 표시
          setTimeout(() => {
            notificationManager.showNotification('알림 설정 완료! 🎉', {
              body: 'Eastalk에서 새 메시지 알림을 보내드릴 수 있어요',
              icon: '/favicon.ico'
            });
          }, 500);
        } else if (permission === 'denied') {
          elements.requestBtn.innerHTML = '❌ 거부됨';
        } else {
          elements.requestBtn.innerHTML = '⚠️ 취소됨';
        }
        
        // 1.5초 후 원래 텍스트로 복원
        setTimeout(() => {
          elements.requestBtn.disabled = false;
          elements.requestBtn.innerHTML = '🔔 브라우저 알림 허용하기';
          updateUI();
        }, 1500);
      });

      // 브라우저 알림 및 소리 알림 체크박스 제거됨 - 항상 활성

      // 탭 제목 및 스마트 모드 체크박스 제거됨 - 항상 활성

      // 소리 종류 선택 제거됨

      // 볼륨 조절 제거됨

      // 소리 테스트 제거됨

      // 초기 UI 상태 설정
      updateUI();
      
      // 프로필 모달이 열릴 때마다 UI 업데이트
      const pmodal = el('#pmodal');
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
            if (pmodal.classList.contains('show')) {
              setTimeout(updateUI, 100); // 모달 애니메이션 후 업데이트
            }
          }
        });
      });
      
      if (pmodal) {
        observer.observe(pmodal, { attributes: true });
      }
      
      console.log('🔔 알림 설정 UI 초기화 완료');
    }


    // ===== Initialize Modern Profile System =====
    // Initialize work status on page load
    document.addEventListener('DOMContentLoaded', function() {
      // ✅ DOM 완전 로드 후 UI 이벤트 바인딩 (터치 이벤트 포함)
      bindUI();
      
      initializeWorkStatus();
      setupEventDelegation(); // 🎧 이벤트 위임 시스템 초기화
      console.log('🔧 Modern Profile System initialized');
      console.log('✅ DOM 로드 완료 - 모든 이벤트 바인딩 완료');
    });

    // 🎧 이벤트 위임 시스템 (메모리 최적화)
    function setupEventDelegation() {
      console.log('🎧 이벤트 위임 시스템 초기화 중...');
      
      // DOM 캐싱 시스템 초기화
      setupDOMCache();
      
      // 성능 모니터링 시작
      PerformanceMonitor.startMemoryMonitoring();
      
      // 중앙 집중식 클릭 이벤트 처리
      document.addEventListener('click', handleGlobalClick, { passive: false });
      
      // 중앙 집중식 입력 이벤트 처리 (메모리 효율적)
      document.addEventListener('input', handleGlobalInput, { passive: true });
      
      // 중앙 집중식 키보드 이벤트 처리
      document.addEventListener('keydown', handleGlobalKeydown, { passive: false });
      
      console.log('✅ 이벤트 위임 시스템 초기화 완료 (메모리 최적화)');
    }

    // 🏃‍♂️ DOM 요소 캐싱 시스템 (성능 최적화)
    const DOMCache = {
      elements: new Map(),
      selectors: new Map(),
      
      // 자주 사용되는 요소들 미리 캐싱
      get(selector) {
        // PerformanceMonitor가 정의된 후에만 추적
        if (typeof PerformanceMonitor !== 'undefined') {
          PerformanceMonitor.trackDOMQuery(); // DOM 쿼리 추적
        }
        
        if (this.elements.has(selector)) {
          const cached = this.elements.get(selector);
          // 요소가 여전히 DOM에 있는지 확인
          if (document.contains(cached)) {
            return cached;
          }
          // 캐시에서 제거
          this.elements.delete(selector);
        }
        
        // 새로 찾아서 캐싱
        const element = document.querySelector(selector);
        if (element) {
          this.elements.set(selector, element);
        }
        return element;
      },
      
      // 캐시 정리 (메모리 누수 방지)
      cleanup() {
        console.log('🧹 DOM 캐시 정리 중...');
        for (const [selector, element] of this.elements.entries()) {
          if (!document.contains(element)) {
            this.elements.delete(selector);
          }
        }
        console.log(`🧹 DOM 캐시 정리 완료 (남은 캐시: ${this.elements.size}개)`);
      }
    };

    function setupDOMCache() {
      // 자주 사용되는 요소들 미리 캐싱
      const commonSelectors = [
        '#profileModal', '#profileEditModal', 
        '.nickname-count', '.status-count',
        '#toggle98', '#avatarPreview'
      ];
      
      commonSelectors.forEach(selector => DOMCache.get(selector));
      
      // 주기적 캐시 정리 (10초마다)
      const cleanupInterval = setInterval(() => DOMCache.cleanup(), 10000);
      
      // 페이지 언로드 시 정리
      window.addEventListener('beforeunload', () => {
        clearInterval(cleanupInterval);
        DOMCache.elements.clear();
        DOMCache.selectors.clear();
      }, { once: true });
      
      console.log('🏃‍♂️ DOM 캐시 시스템 초기화 완료');
    }

    // 🚀 함수 디바운싱/스로틀링 유틸리티 (성능 최적화)
    const PerformanceUtils = {
      // 디바운스된 함수들을 저장
      debouncedFunctions: new Map(),
      throttledFunctions: new Map(),
      
      // 디바운스 함수 생성 및 캐싱
      debounce(fn, delay, key) {
        if (this.debouncedFunctions.has(key)) {
          return this.debouncedFunctions.get(key);
        }
        
        let timeoutId;
        const debouncedFn = (...args) => {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => fn(...args), delay);
        };
        
        this.debouncedFunctions.set(key, debouncedFn);
        return debouncedFn;
      },
      
      // 스로틀 함수 생성 및 캐싱
      throttle(fn, delay, key) {
        if (this.throttledFunctions.has(key)) {
          return this.throttledFunctions.get(key);
        }
        
        let isThrottled = false;
        const throttledFn = (...args) => {
          if (!isThrottled) {
            fn(...args);
            isThrottled = true;
            setTimeout(() => { isThrottled = false; }, delay);
          }
        };
        
        this.throttledFunctions.set(key, throttledFn);
        return throttledFn;
      },
      
      // RAF 기반 최적화된 DOM 업데이트
      scheduleUpdate(callback) {
        if (this.updateScheduled) return;
        this.updateScheduled = true;
        
        requestAnimationFrame(() => {
          callback();
          this.updateScheduled = false;
        });
      }
    };

    // 🧹 메모리 누수 방지 시스템
    const MemoryManager = {
      // 등록된 리스너들 추적
      eventListeners: new Set(),
      intervals: new Set(),
      timeouts: new Set(),
      
      // 안전한 이벤트 리스너 등록
      addEventListenerSafe(element, event, handler, options) {
        element.addEventListener(event, handler, options);
        const cleanup = () => element.removeEventListener(event, handler, options);
        this.eventListeners.add(cleanup);
        return cleanup;
      },
      
      // 안전한 인터벌 등록
      setIntervalSafe(callback, delay) {
        const id = setInterval(callback, delay);
        this.intervals.add(id);
        return id;
      },
      
      // 안전한 타임아웃 등록
      setTimeoutSafe(callback, delay) {
        const id = setTimeout(() => {
          this.timeouts.delete(id);
          callback();
        }, delay);
        this.timeouts.add(id);
        return id;
      },
      
      // 전체 정리
      cleanup() {
        console.log('🧹 메모리 정리 시작...');
        
        // 이벤트 리스너 정리
        this.eventListeners.forEach(cleanup => cleanup());
        this.eventListeners.clear();
        
        // 인터벌 정리
        this.intervals.forEach(id => clearInterval(id));
        this.intervals.clear();
        
        // 타임아웃 정리
        this.timeouts.forEach(id => clearTimeout(id));
        this.timeouts.clear();
        
        console.log('✅ 메모리 정리 완료');
      }
    };

    // 📊 성능 모니터링 시스템 (실시간 성능 추적)
    const PerformanceMonitor = {
      metrics: {
        domQueries: 0,
        eventsFired: 0,
        memoryUsage: 0,
        lastGC: Date.now()
      },
      
      // DOM 쿼리 카운터
      trackDOMQuery() {
        this.metrics.domQueries++;
        
        // 100회마다 성능 리포트 출력
        if (this.metrics.domQueries % 100 === 0) {
          console.log(`📊 성능 통계 - DOM 쿼리: ${this.metrics.domQueries}회, 이벤트: ${this.metrics.eventsFired}회`);
        }
      },
      
      // 이벤트 카운터
      trackEvent() {
        this.metrics.eventsFired++;
      },
      
      // 메모리 사용량 모니터링 (5초마다)
      startMemoryMonitoring() {
        MemoryManager.setIntervalSafe(() => {
          if (performance.memory) {
            const memory = performance.memory;
            this.metrics.memoryUsage = memory.usedJSHeapSize;
            
            // 메모리 사용량이 50MB를 초과하면 경고
            if (memory.usedJSHeapSize > 50 * 1024 * 1024) {
              console.warn(`⚠️ 메모리 사용량 높음: ${(memory.usedJSHeapSize / 1024 / 1024).toFixed(1)}MB`);
              
              // 가비지 컬렉션 강제 실행
              if (global.gc) {
                global.gc();
                this.metrics.lastGC = Date.now();
              }
            }
          }
        }, 5000);
      },
      
      // 성능 최적화 제안
      getOptimizationSuggestions() {
        const suggestions = [];
        
        if (this.metrics.domQueries > 1000) {
          suggestions.push('DOM 쿼리가 많습니다. 요소 캐싱을 더 활용하세요.');
        }
        
        if (this.metrics.memoryUsage > 100 * 1024 * 1024) {
          suggestions.push('메모리 사용량이 높습니다. 사용하지 않는 객체를 정리하세요.');
        }
        
        return suggestions;
      }
    };

    // 페이지 언로드 시 메모리 정리
    window.addEventListener('beforeunload', () => {
      MemoryManager.cleanup();
      PerformanceUtils.debouncedFunctions.clear();
      PerformanceUtils.throttledFunctions.clear();
      
      // 최종 성능 리포트
      console.log('📊 최종 성능 리포트:', {
        domQueries: PerformanceMonitor.metrics.domQueries,
        events: PerformanceMonitor.metrics.eventsFired,
        memoryPeak: (PerformanceMonitor.metrics.memoryUsage / 1024 / 1024).toFixed(1) + 'MB',
        suggestions: PerformanceMonitor.getOptimizationSuggestions()
      });
    }, { once: true });

    // 🎯 전역 클릭 이벤트 핸들러 (이벤트 위임)
    function handleGlobalClick(e) {
      // PerformanceMonitor가 정의된 후에만 추적
      if (typeof PerformanceMonitor !== 'undefined') {
        PerformanceMonitor.trackEvent(); // 이벤트 추적
      }
      
      const target = e.target;
      const closest = target.closest.bind(target);
      
      // 🔄 Win98 토글 처리
      if (target.id === 'toggle98' || closest('#toggle98')) {
        applyTheme98(!document.body.classList.contains('win98')); 
        beep();
        return;
      }
      
      // 📝 프로필 편집 관련 버튼들
      if (closest('.btn-save')) {
        const profileModal = closest('#profileEditModal');
        if (profileModal && window.profileEditManager) {
          window.profileEditManager.saveProfile();
        }
        return;
      }
      
      // 🖼️ 이미지 변경 버튼
      if (closest('.change-image-btn')) {
        if (window.profileEditManager) {
          window.profileEditManager.toggleImageUpload();
        }
        return;
      }
      
      // 💬 답글 버튼들
      if (closest('.reply-btn')) {
        e.stopPropagation();
        const messageElement = closest('.message');
        if (messageElement) {
          const messageId = messageElement.dataset.messageId;
          const senderName = messageElement.dataset.senderName;
          if (messageId && senderName) {
            setReplyTarget(messageId, senderName);
          }
        }
        return;
      }
      
      // 👤 아바타 클릭 (프로필 보기)
      if (closest('.avatar') && !closest('.profile-modal')) {
        const avatar = closest('.avatar');
        const messageElement = avatar.closest('.message');
        if (messageElement) {
          const senderName = messageElement.dataset.senderName;
          if (senderName && senderName !== AppState.me?.nickname) {
            showProfileModal(senderName);
          }
        }
        return;
      }
      
      // 🔙 프로필 모달 뒤로가기/닫기
      if (target.id === 'pback' || target.id === 'pclose') {
        hideProfileModal();
        return;
      }
      
      // 🎯 버튼 그룹들
      if (closest('.btn-group button')) {
        const btn = closest('.btn-group button');
        if (btn.classList.contains('active')) return;
        
        // 형제 버튼들의 active 클래스 제거
        btn.parentNode.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        return;
      }
    }

    // ⌨️ 전역 입력 이벤트 핸들러 (이벤트 위임 + DOM 캐시)
    function handleGlobalInput(e) {
      const target = e.target;
      
      // 📝 닉네임 입력 필드 (글자 수 카운터) - 캐시된 요소 사용
      if (target.classList.contains('edit-nickname') || target.id === 'editNickname') {
        const counter = DOMCache.get('.nickname-count');
        if (counter) {
          counter.textContent = target.value.length;
        }
        return;
      }
      
      // 💭 상태 메시지 입력 필드 (글자 수 카운터) - 캐시된 요소 사용
      if (target.classList.contains('edit-status') || target.id === 'editStatusMessage') {
        const counter = DOMCache.get('.status-count');
        if (counter) {
          counter.textContent = target.value.length;
        }
        return;
      }
      
      // 🖼️ 아바타 URL 입력 필드 - 캐시된 요소 사용
      if (target.id === 'avatarInput') {
        const preview = DOMCache.get('#avatarPreview');
        if (preview) {
          preview.src = target.value || '/favicon.ico';
        }
        return;
      }
    }

    // ⌨️ 전역 키보드 이벤트 핸들러 (이벤트 위임 + DOM 캐시)
    function handleGlobalKeydown(e) {
      // ESC 키로 모달 닫기
      if (e.key === 'Escape') {
        // 프로필 모달 닫기 - 캐시된 요소 사용
        const profileModal = DOMCache.get('#profileModal');
        if (profileModal?.style.display !== 'none') {
          hideProfileModal();
          return;
        }
        
        // 프로필 편집 모달 닫기
        if (window.profileEditManager && window.profileEditManager.isOpen()) {
          window.profileEditManager.close();
          return;
        }
      }
      
      // 엔터 키 처리 (텍스트 에디터 제외)
      if (e.key === 'Enter' && !e.target.classList.contains('content-editable')) {
        const target = e.target;
        
        // 프로필 편집 모달에서 엔터 키 - 캐시된 요소 사용
        const profileEditModal = DOMCache.get('#profileEditModal');
        if (profileEditModal && target.closest('#profileEditModal')) {
          e.preventDefault();
          if (window.profileEditManager) {
            window.profileEditManager.saveProfile();
          }
          return;
        }
      }
    }

    // Function to update dropdown info (if dropdown exists)
    function updateDropdownInfo() {
      // Check if dropdownStatus element exists, if not, skip silently
      const dropdownStatus = document.getElementById('dropdownStatus');
      if (dropdownStatus && AppState.userId) {
        const currentWorkStatus = window.currentWorkStatus || 'offline';
        const status = workStatuses[currentWorkStatus] || workStatuses.offline;
        dropdownStatus.textContent = status.text;
      }
    }

    // Initialize work status when user logs in
    const originalUpdateProfile = window.updateProfileUI || updateProfileUI;
    window.updateProfileUI = function() {
      originalUpdateProfile.apply(this, arguments);
      initializeWorkStatus(); // Re-initialize work status on profile update
      updateDropdownInfo(); // Update dropdown info
    };
  </script>

  <!-- Profile Edit Modal -->
  <div id="profileEditModal" class="modal-overlay" style="display: none;">
    <div class="modal-container">
      <div class="modal-header">
        <h3>프로필 편집</h3>
        <button class="modal-close" onclick="closeProfileEditModal()">&times;</button>
      </div>
      
      <div class="modal-content">
        <!-- 프로필 이미지 섹션 -->
        <div class="profile-image-section">
          <div class="current-profile-image">
            <img id="currentProfileImg" src="" alt="프로필 이미지">
            <div class="profile-image-overlay">
              <button id="changeImageBtn" class="change-image-btn">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                  <circle cx="12" cy="13" r="4"></circle>
                </svg>
                <span>변경</span>
              </button>
            </div>
          </div>
          <div id="imageUploadArea" class="upload-area" style="display: none;">
            <div id="uppyDashboard"></div>
          </div>
        </div>
        
        <!-- 프로필 정보 섹션 -->
        <div class="profile-info-section">
          <div class="input-group">
            <label for="editNickname">닉네임</label>
            <input type="text" id="editNickname" placeholder="닉네임을 입력하세요" maxlength="20">
            <div class="char-count"><span id="nicknameCount">0</span>/20</div>
          </div>
          
          <div class="input-group">
            <label for="editStatusMessage">상태 메시지</label>
            <textarea id="editStatusMessage" placeholder="상태 메시지를 입력하세요" maxlength="50" rows="2"></textarea>
            <div class="char-count"><span id="statusCount">0</span>/50</div>
          </div>
        </div>
      </div>
      
      <div class="modal-footer">
        <button class="btn btn-cancel" onclick="closeProfileEditModal()">취소</button>
        <button class="btn btn-save" onclick="saveProfileChanges()">저장</button>
      </div>
    </div>
  </div>

  <!-- Uppy.js CSS -->
  <link href="https://releases.transloadit.com/uppy/v3.25.0/uppy.min.css" rel="stylesheet">
  
  <!-- Uppy.js JavaScript -->
  <script src="https://releases.transloadit.com/uppy/v3.25.0/uppy.min.js"></script>
  
  <!-- Connected Users Modal -->
  <div class="work-status-modal" id="connectedUsersModal" style="display: none;">
    <div class="work-status-dialog">
      <div class="status-header">
        <h3>현재 접속자</h3>
        <button class="modal-close" onclick="closeConnectedUsersModal()">✕</button>
      </div>
      <div class="status-content" id="connectedUsersContent">
        <div class="connected-users-list" id="mobileConnectedUsersList">
          <!-- 접속자 목록이 여기에 렌더링됩니다 -->
        </div>
      </div>
    </div>
  </div>

  <!-- Work Status Selector Modal (Hidden by default) -->
  <div id="workStatusModal" class="work-status-modal" style="display:none;">
    <div class="work-status-dialog">
      <div class="status-header">
        <h3 class="status-title">업무 상태 변경</h3>
        <button class="status-close" onclick="closeWorkStatusSelector()">✕</button>
      </div>
      <div class="status-options">
        <button class="status-option" data-status="ticketing" onclick="selectWorkStatusTemp('ticketing')">
          <span class="status-option-icon">🎫</span>
          <div class="status-option-info">
            <div class="status-option-name">발권</div>
            <div class="status-option-desc">발권 업무 진행 중</div>
          </div>
        </button>
        <button class="status-option" data-status="checking" onclick="selectWorkStatusTemp('checking')">
          <span class="status-option-icon">✅</span>
          <div class="status-option-info">
            <div class="status-option-name">검표</div>
            <div class="status-option-desc">검표 업무 진행 중</div>
          </div>
        </button>
        <button class="status-option" data-status="patrol" onclick="selectWorkStatusTemp('patrol')">
          <span class="status-option-icon">🚶</span>
          <div class="status-option-info">
            <div class="status-option-name">순찰</div>
            <div class="status-option-desc">순찰 중</div>
          </div>
        </button>
        <button class="status-option" data-status="artshop" onclick="selectWorkStatusTemp('artshop')">
          <span class="status-option-icon">🎨</span>
          <div class="status-option-info">
            <div class="status-option-name">아트샵</div>
            <div class="status-option-desc">아트샵 업무 중</div>
          </div>
        </button>
        <button class="status-option" data-status="offline" onclick="selectWorkStatusTemp('offline')">
          <span class="status-option-icon">⚪</span>
          <div class="status-option-info">
            <div class="status-option-name">오프라인</div>
            <div class="status-option-desc">업무 종료</div>
          </div>
        </button>
      </div>
      <div class="status-actions">
        <button class="status-cancel-btn" onclick="cancelWorkStatusChange()">취소</button>
        <button class="status-save-btn" onclick="saveWorkStatusChange()">저장</button>
      </div>
    </div>
  </div>
  
</body>
</html>